# 手写常见代码

## 浅深拷贝

- 浅拷贝: 拷贝对象中的第一层属性，如果是引用数据类型，只拷贝地址

- 深拷贝：拷贝数组中的元素，如果是引用数据类型，只拷贝地址


### 浅拷贝1
- 利用es6的扩展运算符
```js
    // 浅拷贝
    // 1,es6,扩展运算符
    function clone1(target) {
        // 如果是引用数据类型（对象，数组）
        if (target !== null && typeof target === "object") {
            if (Array.isArray(target)) {
                return [...target]
            } else {
                return { ...target }
            }
        } else {// 如果是基本数据类型或者函数
            return target
        }
    }
```

### 浅拷贝2
- 利用es5的for(let key in target)遍历

```js
    // 2,es5,for(let key in target)
    function clone2(target) {
        // 如果是引用数据类型（对象，数组）
        if (target !== null && typeof target === "object") {
            let cloneTarget = Array.isArray(target) ? [] : {}
            for (let key in target) {
                // 自身对象上的属性，不能是对象原型中的属性
                if (target.hasOwnProperty(key)) {
                    cloneTarget[key] = target[key]
                }
            }
            return cloneTarget
        } else {// 如果是基本数据类型或者函数
            return target
        }
    }
```

### 深拷贝1
- 乞丐版，会出现函数属性会丢失，循环引用会报错两个问题
```js
    // 大众乞丐版：（）
    function deepClone1(target) {
        return JSON.parse(JSON.stringify(target))
    }
```

### 深拷贝2
- 加强版，运用递归遍历方式，解决函数属性丢失
```js
    // 强化一
    function deepClone2(target) {
        // 如果是引用数据类型（对象，数组）
        if (target !== null && typeof target === "object") {
            let cloneTarget = Array.isArray(target) ? [] : {}
            for (let key in target) {
                // 自身对象上的属性，不能是对象原型中的属性
                if (target.hasOwnProperty(key)) {
                    cloneTarget[key] = deepClone2(target[key])
                }
            }
            return cloneTarget
        } else {// 如果是基本数据类型或者函数
            return target
        }
    }
```
### 深拷贝3
- 加强升级版
- 运用递归遍历方式，缓存以克隆的对象或数组，解决函数属性丢失和循环引用会报错两个问题
        
```js
    // 强化二
    // 解决函数属性丢失(运用递归遍历)
    // 解决循环引用会报错问题(deepClone2(p),Uncaught RangeError: Maximum call stack size exceeded)
    // 将克隆的相同对象缓存起来
    function deepClone3(target,map = new Map()){
        // 如果是引用数据类型（对象，数组）
        if (target !== null && typeof target === "object") {
            if(map.get(target)){
                return map.get(target)
            }
            let cloneTarget = Array.isArray(target) ? [] : {}
            // 设置缓存对象
            map.set(target,cloneTarget)
            for (let key in target) {
                // 自身对象上的属性，不能是对象原型中的属性
                if (target.hasOwnProperty(key)) {
                    cloneTarget[key] = deepClone3(target[key],map)
                }
            }
            return cloneTarget
        } else {// 如果是基本数据类型或者函数
            return target
        }
    }
    let p = { a: 1, b: 2, c: [1, 2, 3], d: { a: 1 } }
    p.c.push(p.d)
    p.d.xx = p.c
    console.log(deepClone3(p) === p);
```

## 数组扁平化

### 使用数组原型中的falt方法

```js
let arr = [1, 2, 3, [4, 5, 6, [7, 8, [9, 10, 11]]]];
arr.flat(Infinity);
```

### toSting，split
如果都是数字，可再进行遍历讲字符串转为数字
```js
let arr = [1, 2, 3, [4, 5, 6, [7, 8, [9, 10, 11]]]];
arr.toString().split(',')
```

### 三点运算符
```js
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        // 会将数组和非数组合并到一起
        arr = [].concat(...arr);
    }
    return arr;
}
```