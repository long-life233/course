# JS(铭哥)

## 概述

#### 特点

JavaScript 是一门**动态的**，**弱类型**的，**解释型**的，**基于对象**的**脚本**语言。

**动态：** 程序执行的时候才会确定数据类型。 **静态：** 书写代码的时候提前确定数据类型。

**弱类型：** 数据类型可以自动转换。 **强类型：** 数据类型无法自动转换。

**解释型：** 边编译，边运行，开发效率更高。 **编译型：** 先编译，后运行，运行效率更高。

**脚本：**一般都是可以嵌在其它编程语言当中执行。

#### 运行环境

所有的高级编程语言都无法直接在电脑上运行，需要安装运行环境，编译型语言的运行环境称之为**编译器**，解释型语言的运行环境称之为**解释器**。

运行环境负责把编程语言编译为机器码。

JavaScript 的运行环境是**浏览器**或者**Node.js**。

#### 浏览器JS组成部分

* ECMAScript， JavaScript 的基本语法。
* BOM   浏览器对象模型， 浏览器提供给 JavaScript 的接口。
* DOM  文档对象模型， 文档页面（HTML和CSS）提供给 JavaScript 的接口。

## 基本语法

### 三种使用方式

####  ① 行内式

配合属性，把JS代码写在HTML标签里面。

```html
<button onclick="JS代码..."></button>
<button ondblclick="JS代码..."></button>
```

#### ② 内嵌式

使用 script 标签，把JS代码写在 script 双标签之间。

```html
<script>
	JS 代码...
</script>
```

> 注意： 建议CSS写在 head 标签内，而 JS 代码建议写在其他HTML元素的最后面。

#### ③ 外链式

js 代码写在独立的 js 文件中，在 html 中使用 script 标签的 src 属性引入 js 文件。

```html
<script src="js文件的地址"></script>
```

> **注意：** 外链式与内嵌式不要共用一个 script 标签。

### 注释

```js
// 单行注释
// alert('ok');

/*
 多行注释
 多行注释
 多行注释
*/
```

### 语法特点

```
1. JavaScript 中严格区分大小写。
2. 每条JavaScript语句结束需要语句结束符，分号或者换行都可以作为语句结束符。
```

### 输出内容

#### ① 输出到弹框

```js
alert(内容 , 可以都好隔开);
```

#### ② 输出到页面中

```js
document.write(内容 , 逗号隔开)
```

#### ③ 输出到控制台

```css
console.log(内容 , 逗号隔开);
```



## 变量



### 数据、直接量、变量

**数据：** 计算机计算的就是数据，运算的结果也是数据。

**直接量：** 直接使用数据就是直接量。

**变量：** 给数据取个名字，使用该名字就可以使用数据了。

### 意义

1. 用变量给数据取了名字，通过变量就可以使用数据，方便对数据的多次重复使用。
2. 使用变量可以把数据存储下来，保证后续使用的还是原来的数据。

### 语法

1、把数据给变量的过程称之为**给变量赋值**， 存储到变量中的数据称之为**变量的值**。

2、如果要创建新的变量，需要使用关键字 **var**，如果使用的变量已经存在不需要关键字 **var**

```js
// 创建一个变量
var username;

// 创建变量并且赋值
var age = 1000;
var address = age;

// 修改变量的值(给变量赋新的值)
username = '芳芳';
address = '上海'

// 同时创建多个变量
var a,b,c;

// 同时创建多个变量并且赋值
var a = 100, b = 200, c = 300;
```

### 命名规范

#### ① 强制规范

1、变量名必须由数字、字母、下划线、$ 组成并且不能以数字开头。

2、变量名不能是关键字或保留字。

> **关键字：** 在 JS 中具有特殊意义的词。
>
> **保留字：** 目前在 JS 中还没有特殊意义，但是将来可能会具有特殊意义的词。

#### ② 建议规范

1、变量名应该是由有意义的单词组成。

2、如果变量名是由多个单词组成，建议使用小驼峰命名法，如 `homeAddress`、 `userHomeAddress`。



## 数据类型

### 分类

#### ① 原始类型

```
number		数值类型

string		字符串类型

boolean		布尔类型

undefined	未定义类型

null		空类型
```

#### ② 对象类型

```
Array
Object
Function
RegExp
Error
Math
Date
..........
```



### ~详解

```
typeof()
```



#### number

##### ① 整型

```js
var n1 = 89;  // 十进制表示
var n2 = 010; // 八进制表示
var n3 = 0x10;  // 十六进制表示
```

##### ② 浮点型

```js
var n4 = 34.009;
var n5 = 78.0;
var n6 = 45e-2;  // 科学计数法 
```

> **注意：**
>
> 浮点数的计算存在精度问题！原因小数转为二进制有循环

##### ③ NaN

NaN 全称 Not a Number， 是一个特殊的 number 类型的值。

NaN 这个值具有两个特点：

1. NaN 与任何数进行任何运算，计算结果还是 NaN。
2. NaN 与任何数都不相等，包括自己。

使用 isNaN() 函数可以判断一个数是不是 NaN。

##### ④ JS数字有效范围

JavaScript 可以表示的数字存在有效范围，5e324 ~ 1.7976931348623157e+308  。

如果超出有效范围，会用 Infinity（正无穷） 或者 -Infinity（负无穷） 来表示，Infinity 和 -Infinity 是特殊的 number 类型值。

使用 isFinite() 函数来判断一个数字是否在有效范围内。



#### string

##### ① 字符串表示方式

```js
// 使用单引号
'字符串内容'

// 使用双引号
"字符串内容"
```

> **注意：**
>
> 1. 使用单引号定义字符串与使用双引号定义字符串没有任何区别。
> 2. 单引号定义的字符串内容中中不允许写单引号；双引号定义的字符串内容中不允许写双引号。

##### ② 转义字符

```
\n		表示换行符
\\		表示\本身
\'		用于在单引号定义的字符串中使用单引号
\"		用于在双引号定义的字符串中使用双引号
```



#### boolean

布尔类型的数据有两个值，分别是 true 和 false。

#### null & undefined

**`null`表示没有对象，即该处不应该有值：**

1） 作为函数的参数，表示该函数的参数不是对象。

2） 作为对象原型链的终点。

3） 获取 DOM 获取不到的时候。

**`undefined`表示缺少值，即此处应该有值，但没有定义：**

1）定义了变量没有给值，显示 undefined。

1）定义了形参，没有传实参，显示 undefined。

2）对象属性名不存在时，显示 undefined。

3）函数没有写返回值，即没有写return，拿到的是 undefined。

4）写了return，但没有赋值，拿到的是 undefined。

> **注意：** 使用 typeof 判断 null 的数据类型，得到是 object。



### ~转换

#### 默认转换

##### ① 其他类型转为 number 

```
1. string 转为 number 类型的规则：

   1) 纯数字字符串会转为对应的数字，十六进制表示以及科学计数法表示的数字都是纯数字。
   2) 空字符串转为数字 0。
   3) 其他字符串转为 NaN。
   4) 自动去掉两端空格
   
2. boolean 转为 number 类型的规则：
   true -> 1
   false -> 0
   
3. null 转为 number 类型的规则：
   null -> 0
   
4. undefeind 转为 number 类型的规则：
   undefined -> NaN
```

##### ② 其他类型转为 string

```
数据长什么样就转为什么样的字符串
```

##### ③ 其他类型转为 boolean

```
1. number 转为 boolean 类型的规则：
   0 和 NaN 转为 false，其他数字都转为 true
   
2. string 转为 boolean 类型的规则：
   空字符串转为 false，其他字符串都转为 true
   
3. null 转为 boolean 类型的规则：
   null -> false
   
4. undefeind 转为 boolean 类型的规则：
   undefiend -> false
```

> **总结：** 0、NaN、空字符串、null、undefined 转为布尔值会转为 false，其他数据转为布尔值都是 true。

#### 函数转换

##### ① 转为 number

```
Number()
parseInt()				------------提取整数部分 , 取出其它字符
parseFloat()
```

> **parsentInt()、parsentFloat 与 Number 的区别：**
>
> 1. parseInt() 和 parentFloat() 用于提取字符串的数字，所有非字符串类型得到的都是 NaN
> 2. 纯数字字符串转为对应的数字；以数字开头的字符串转为开头的数字；其他字符串都是 NaN（空字符也是NaN）
>
> **parseInt() 和 parsentFloat() 的区别：**
>
> 1. parseInt() 只能提取字符串中的整数部分。
> 2. parentFloat() 可以提取字符串中的小数部分.

> **注意：**
>
> 1. Number() 的转换规则此时标准的转换规则。
> 2. 可以使用 parsetInt() 来对某个数字进行取整（会把小数部分舍去）。

##### ② 转为 string

```
String()


toFixed() 
方法可把 Number 四舍五入为指定小数位数的数字。
var num = 5.56789;
var n=num.toFixed(2);
5.57
```

##### ③ 转为 boolean

```
Boolean()
```

#### 自动转换

1. JavaScript 作为**弱类型**编程语言，支持数据类型自动转换。

2. 数据参与运算，数据不符合运算所要求的类型，数据会根据运算要求的类型自动转换。
3. 运算所要求的数据类型由**运算符**绝对。
4. 自动类型转换的规则与强制类型（Number、String、Boolean）转换的规则是一样的。



## 运算符

### MDN

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators

### 运算符和表达式

#### 运算符

运算符就是参与运算的符号，像`+`、`-`、`*`、`/` 等。

与运算符一起运算的变量、直接量、表达式称之为**操作数**。

#### 表达式

1) 表达式是变量或者直接量与运算符组成的式子，表达式会有一个计算结果，称之为**表达式的值**，也就是说表达式是有值的。

2) 最简单的表达式是"原始表达式", 如 直接量、 变量名、 关键字等。

3) 复杂表达式由简单表达式组成, 运算符何以将简单表达式组合成复杂表达式。

4) 注意**带有副作用的表达式**，这样的表达式除了有表达式的计算结果之外，还会对表达式中的变量产生影响。

### 运算符的分类

#### 按照操作个数

```
一元运算符/一目运算符
二元运算符/二目运算符
三元运算符/三目运算符
```

#### 按照功能

```
算术运算符
关系运算符
逻辑运算符
位运算符
赋值运算符
其他运算符
```

### 运算符讲解

（按照功能）

#### 算术~

| 运算符 | 含义              | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型 | 有无副作用 |
| ------ | ----------------- | ---------- | ---------------- | ---------------------- | ---------- |
| +      | 加号              | 2          | number           | number                 | 无         |
| -      | 减号              | 2          | number           | number                 | 无         |
| *      | 乘号              | 2          | number           | number                 | 无         |
| **     | 幂,如<br>3**2,为9 | 2          | number           | number                 | 有         |
| /      | 除号              | 2          | number           | number                 | 无         |
| %      | 取余（取模）      | 2          | number           | number                 | 无         |
| +      | 正号              | 1          | number           | number                 | 无         |
| -      | 负号              | 1          | number           | number                 | 无         |
| ++     | 累加              | 1          | number           | number                 | 有         |
| --     | 累减              | 1          | number           | number                 | 有         |

> **正号运算符：**
>
> 通常会使用正号运算符来把其他类型的数据转为 number 类型，利用运算符自动类型转换。
>
> **累加运算符和累减运算符：**
>
> 累加和累减都是一元运算符，操作数必须以变量的形式表示，具有副作用。
>
> 累加和累减的符号可以在操作数的前面也可以在操作数的后面，对操作数产生的副作用是一样的，但是所组成的表达式的值不同。
>
> 运算符在操作前面： 表单式取操作数累加或累减之后的值作为表达式的值。
>
> 运算符在操作数后面：表达式取操作数累加或累减之前的值作为表达式的值。
>
> ![image-20210320140503675](TyporaImg/image-20210320140503675.png)

#### 比较（关系）~

| 运算符     | 含义                                              | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型 | 有无副作用 |
| ---------- | ------------------------------------------------- | ---------- | ---------------- | ---------------------- | ---------- |
| >          | 大于                                              | 2          | number、string   | boolean                | 无         |
| >=         | 大于等于                                          | 2          | number、string   | boolean                | 无         |
| <          | 小于                                              | 2          | number、string   | boolean                | 无         |
| <=         | 小于等于                                          | 2          | number、string   | boolean                | 无         |
| ==         | 相等                                              | 2          | number、其他类型 | boolean                | 无         |
| !=         | 不相等                                            | 2          | number、其他类型 | boolean                | 无         |
| ===        | 全等                                              | 2          | 所有类型         | boolean                | 无         |
| !==        | 不全等                                            | 2          | 所有类型         | boolean                | 无         |
| in         | 判断一个属性是否属于一个对象( 原型 , 实例中皆可 ) | 2          |                  | boolean                | 无         |
| instanceof | 判断一个对象的实例是否属于某个对象                | 2          |                  | boolean                | 无         |

> 两个数据在使用关系运算符进行判等的时候，会发生自动类型转换，规则如下：
>
> 1）判等的时候（`==`）：
>
> -   先看两边是不是同种数据类型，如果是直接看是不是一样；如果不是那么两边都转数字
> -   当遇到 null 的时候，会有特殊情况发生。
>     -   特殊情况：空串和null不相等
>     -   特殊情况：false和null不相等
>     -   特殊情况：0      和null不相等
>     -   特殊情况：`undefined 和 null 相等`；
>
> 2）判断全等（`===`）：（不会出现类型转换）
>
> -   在判断全等的时候，必须类型和值都相同。
> -   如果有一个不一样，就不全等；

#### 逻辑~

| 运算符 | 含义   | 操作数个数 | 操作数的类型要求 | 组成的表达式的值的类型         | 有无副作用 |
| ------ | ------ | ---------- | ---------------- | ------------------------------ | ---------- |
| &&     | 逻辑与 | 2          | 任何类型         | 取其中一个操作数作为表达式的值 | 无         |
| \|\|   | 逻辑或 | 2          | 任何类型         | 取其中一个操作数作为表达式的值 | 无         |
| !      | 逻辑非 | 1          | boolean          | boolean                        | 无         |

> **逻辑与组成的表达式的值的计算规则：**
>
> 1. 如果第一个操作数不成立，取第一个操作数作为表达式的值。
> 2. 如果第一个操作数成立，取第二个操作数作为表达式的值。
>
> **逻辑或组成的表达式的值的计算规则：**
>
> 1. 如果第一个操作数不成立，取第二个操作数作为表达式的值。
> 2. 如果第一个操作数成立，取第一个操作数作为表达式的值。

#### 位~

转为二进制计算

| 运算符 | 运算符含义           | 操作数个数 | 组成的表达式的值的类型 | 组成的表达式有无副作用 |
| ------ | -------------------- | ---------- | ---------------------- | ---------------------- |
| &      | 按位与运算符         | 2          | interger               | 无                     |
| \|     | 按位或运算符         | 2          | interger               | 无                     |
| ^      | 按位异或运算符       | 2          | interger               | 无                     |
| ~      | 按位非运算符         | 1          | interger               | 无                     |
| <<     | 按位左移运算符       | 1          | interger               | 无                     |
| >>     | 按位右移运算符       | 1          | interger               | 无                     |
| >>>    | 按位无符号右移运算符 | 1          | interger               | 无                     |

#### 赋值~

| =    | 赋值运算符             | 2    | 取决于右边的操作数 | 有   |
| ---- | ---------------------- | ---- | ------------------ | ---- |
| +=   | 赋值求和运算符         | 2    | number             | 有   |
| -=   | 赋值求差运算符         | 2    | number             | 有   |
| *=   | 赋值求积运算符         | 2    | number             | 有   |
| /=   | 赋值商运算符           | 2    | number             | 有   |
| %=   | 赋值求余运算           | 2    | number             | 有   |
| &=   | 赋值按位与运算符       | 2    | interger           | 有   |
| \|=  | 赋值按位或运算符       | 2    | interger           | 有   |
| ^=   | 赋值按位异或运算符     | 2    | interger           | 有   |
| <<=  | 赋值左位移运算符       | 2    | interger           | 有   |
| >>=  | 赋值右位移运算符       | 2    | interger           | 有   |
| >>>= | 赋值无符号右位移运算符 | 2    | interger           | 有   |
| +=   | 赋值字符串连接运算符   | 2    | string             | 有   |

#### 其他~

| 运算符       | 运算符含义                                  | 操作数个数 | 组成的表达式的值的类型   | 组成的表达式有无副作用 |
| ------------ | ------------------------------------------- | ---------- | ------------------------ | ---------------------- |
| `?:`         | 条件运算符（JavaScript 中唯一的三元运算符） | 3          | 取决于中间和后面的操作数 | 无                     |
| `typeof`     | 判断操作数类型,运算符,和typeof()函数不同    | 1          | string                   | 无                     |
| `+`          | 字符串连接符                                | 2          | string                   | 无                     |
| `delete`     | 删除对象属性或者数组元素                    | 1          | boolean                  | 有                     |
| `,`          | 可以在一条语句中执行多个运算。              | 2          | 取决于第二个操作数的值   | 无                     |
| `instanceof` | 是否某个类的实例                            | 1          | boolean                  | 无                     |
| `.`          |                                             |            |                          |                        |
| `[]`         |                                             |            |                          |                        |

1）运算符， 如`obj.name`

2）运算符，如 `obj['name']`。 属性名要以字符串形式给出，也可以以变量的形式给出。

>   **注意：**
>
>   设置属性值的时候，属性已经存在，就修改属性值；如果属性不存在，就添加属性。 获取对象中不存在的属性的时候，返回 `undefined`
>
>   **注意：**在以下情况下我们必须使用`[]`语法操作：
>
>   ① 如果对象的属性名不符合标识命名规范（变量名的命名规范）。
>
>   ② 如果需要使用变量的值作为属性名。

![image-20210329141643861](TyporaImg/image-20210329141643861.png)

### 运算符优先级

![运算符优先级](TyporaImg/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png)



#### 坑题

    <script>
        var i = 100;
        i = i--; //将i--表达式的值赋给 i ,i--太快 ,表达式赋值慢      //先执行i-- , 但是在第二步中才会
      //汽车 ,快 ,100 , 99 , 100               //改变自身值 , 
        console.log(i);//
    </script>


```
var n = 100;
console.log(n ++ && n --);  //101
console.log(n);				//100
console.log(-- n || n ++);  //99
console.log(n);				//99 
```



## 流程控制语句



### 分支结构

#### 单向分支

```css
if (条件表达式) {
    语句 ...;
}
```

#### 双向分支

```js
if (条件表达式) {
    语句 ...;
} else {
    语句 ...;
}
```

#### 多向分支 else if

```js
if (条件表达式) {

} else if (条件表达式) {

} else if (条件表达式) {

} else if (条件表达式) {

} else {

}
```

#### 多向分支 switch case

```js
sitch (表达式) {
    case 表达式可能的值: 
    	语句...;
    	break;
    case 表达式可能的值:
    	语句...;
    	break;
    case 表达式可能的值: 
    	语句...;
    	break;
    case 表达式可能的值: 
    	语句...;
    	break;
	defalut:
    	语句
}

swithc (true) {
    case num < 0;
    	alert('less than 0')
        break;
    ...
    
    ...
    
    ...
}
```

> **总结：**
>
> 1. 判断条件是判等的多向分享，适合使用 switch case 结构。
> 2. switch case 判等是按照全等（===）的规则进行判等。
> 3. break 结束本 case 中代码的执行，如果没有 break，会一直向下执行，直到执行 break。 



#### 嵌套分支

```js
if (条件表达式) {
    if (条件表达式) {
        
    }    
} else {
    if (条件表达式) {
        
    } else {
        
    }
}
```







### 循环语句

#### while 循环

```js
while (条件表达式) {
    语句...;
}
```

> **正常的循环：**
>
> 1. 循环条件不能永远都成立，否则会变为**死循环**。
> 2. 随着循环次数的增加，循环条件应该越来越趋近于不成立。

#### do while 循环

```js
do {
    语句...
} while (条件表达式)
```

> **while 循环和 do-while 循环的区别：**
>
> 1. 第一次循环，while 先判断再执行； do while 先执行一次。
> 2. 第二次以及往后的循环，二者都一样都是先判断再执行。
> 3. 循环同样的次数，二者循环条件表达式是一样的，do while 只比 while 少判读了一次。

#### for 循环

```js
for (循环标记变量初始化; 循环条件; 循环标记变量的变化) {
    语句...
}
```

> **总结：**
>
> 1. 标记变量初始化	只	执行一次
> 2. 循环条件成立才执行，与 while 一致
> 3. 标记变量变化在循环体语句执行结束后 才执行
> 4. for循环·结束后 , 标记变量是`不符条件`状态



#### 铭哥乘法表(4个)

99乘法表几种



![image-20210323184933084](TyporaImg/image-20210323184933084.png)

```js
<style>
    table{
        border-collapse: collapse;
        /* border: 1px solid #000; */
    }
    td{
        border: 1px solid #000;
        padding: 5px;
    }
</style>
<body>
    <!-- 左下三角 -->
    <script>
        document.write('<table>');
        var i = 1 ;
        while(i <= 9){
            var j = 1;
            document.write('<tr>')
            while(j <= i){
                document.write('<td>' + j + '&times;' + i + '=' + j*i + '</td>');
                j++;
            }
            document.write('</tr>')
            i++;
        }


        document.write('</table>');
    </script>
</body>
```

![image-20210323185300024](TyporaImg/image-20210323185300024.png)

```js
    <!-- 左上三角 -->
    <script>
        document.write('<table>');
        var i = 9 ;
        while(i >=1){
            var j = 1;
            document.write('<tr>')
            while(j <= i){
                document.write('<td>' + j + '&times;' + i + '=' + j*i + '</td>');
                j++;
            }
            document.write('</tr>')
            i--;
        }


        document.write('</table>');
    </script>
```

![image-20210323192157814](TyporaImg/image-20210323192157814.png)

```html
<style>
    table {
        /* text-align: right; */
        border-collapse: collapse;
        /* border: 1px solid #000; */
        /* table-layout: fixed; */
        /* width: 100%; */
    }

    td {
        width: 40px;
        /* display: inline-block; */
        border: 1px solid #000;
        padding: 5px;
    }
    /* .a{
        border:none;
    } */
</style>

<body>
    <!-- 右下三角 -->
    <script>
        document.write('<table>');
        var i = 1;
        while (i <= 9) {
            var j = 1;
            document.write('<tr>')
                for (var k = 9 -i; k >= 1; k--) {
                    document.write('<td style="border:none"></td>')
                }
                while (j <= i) {
                    document.write('<td>' + j + '&times;' + i + '=' + j * i + '</td>');
                    j++;
                }
            document.write('</tr>')
            i++;
        }


        document.write('</table>');
    </script>
</body>
```



![image-20210323192252555](TyporaImg/image-20210323192252555.png)

```js
<style>
    table {
        /* text-align: right; */
        border-collapse: collapse;
        /* border: 1px solid #000; */
        /* table-layout: fixed; */
        /* width: 100%; */
    }

    td {
        width: 40px;
        /* display: inline-block; */
        border: 1px solid #000;
        padding: 5px;
    }
    /* .a{
        border:none;
    } */
</style>

<body>
    <!-- 右下三角 -->
    <script>
        document.write('<table>');
        var i = 9;
        while (i >= 1) {
            var j = 1;
            document.write('<tr>')
                for (var k = 9 -i; k >= 1; k--) {
                    document.write('<td style="border:none"></td>')
                }
                while (j <= i) {
                    document.write('<td>' + j + '&times;' + i + '=' + j * i + '</td>');
                    j++;
                }
            document.write('</tr>')
            i--;
        }


        document.write('</table>');
    </script>
</body>
```

>   取一个数的位数 , 先把所求数变成个位数 , 然后用10 取余
>
>   按照规律 , 掌握规律





### 跳转语句

#### break

在 switch case 中使用： 结束当前 case。

在循环（for、while、do while）中使用： 跳出并结束循环。

#### continue

在循环（for、while、do while）中使用：跳出本次循环，下次循环继续。



### 其他语句

#### 异常处理语句

-   `throw` 抛出异常
-   `try`/`catch`/`finally`

```js
try {
    tryCode - 尝试执行代码块
}
catch(err) {
    catchCode - 捕获错误的代码块
} 
finally {
    finallyCode - 无论 try / catch 结果如何都会执行的代码块
}
```

#### 严格模式

```js
"use strict"
code...
```

#### with 语句

```js
with (document) {
    write('hello,100<br>');
  write('hello,200<br>');
  write('hello,300<br>');
  write('hello,400<br>');
}
```

## 数组

### 什么是数组

1) 数组是值的**有序集合**。

2) 每个值叫做一个**元素**。

3) 每个元素在数组中有一个位置, 以数字表示,称为**索引** (有时也称为下标)。

4) 数组的元素可以是任何类型的数据。

5) 数组索引从 0 开始, 最大为 2^32-2，数组最大能容纳 4294967294 个元素。

### 声明数组方式

#### ① 直接量方式

```js
[元素1， 元素2，元素3 ...];
```

#### ② Array 函数方式

```js
Array(元素1， 元素2，元素3 ...);
Array(10);   // 声明一个拥有10个元素的数组
```

> **注意：** Array 如果只有一个参数，且该参数是 number，该参数会被当做数组的个数 

#### ③ Array 构造函数方式

```js
new Array(元素1， 元素2，元素3 ...);
new Array(10);   // 声明一个拥有10个元素的数组
```

> **注释：** new Array() 和 Array() 相关规则完全一致的。

### 数组元素读写

```js
// 1. 通过索引读取数组中的元素, 如果读取不存在的元素会得到 undefined
arr[4];

// 2. 通过索引给数组的元素重新赋值, 如果给不存在的元素赋值会给数组新增一个元素
arr[2] = '芳芳';

// 3. length 可以获取数组的长度（数组中元素的个数）， length 的值还可以修改（可能导致数组被截取）
arr.length;
```

### 稀疏数组

* 数组要求元素的索引必须是连续的数字。
* 如果出现有些元素没有值是空的，这样的数组就是**稀疏数组**。
* 如果读取空的元素的值，会得到 undefined。（注意：空的元素值就是空的，只是读取该元素自动得到 undefined）。
* 产生稀疏数组的情况：① 使用索引赋值，与前面的索引不连续； ② 修改数组的 length，给了比较大的值； 注意：要尽量避免稀疏数组。

>   用`forEach()`遍历不出来

![image-20210419134213494](TyporaImg/image-20210419134213494.png)

### 数组遍历(迭代)

```js
// 使用 for 循环遍历数组   推荐方式
for (var i = 0; i < 数组.length; i ++) {
    数组[i];  // 读取到数组的每个元素
}


// 使用 for in 结构比遍历数组  不推荐
for (var i in 数组) {
    数组[i];  // 读取到数组的每个元素
}
```

数组遍历 , forin(专为对象准备 , 数组可看成对象)遍历经常遍历出一些我们不想要属性

![image-20210324142312802](TyporaImg/image-20210324142312802.png)

### 数组元素添加/删除

#### 添加元素

```
1. 指定下一个索引，给数组添加元素，可以利用 数组.length
   arr[arr.length] = '值';
   
2. 使用 push() 方法在数组的后面追加一个或多个元素
   arr.push(值);
   arr.push(值1,值2..,)
   
3. 使用 unshift() 方法在数组的最前面添加一个或多个元素
   arr.unshift(值);
   arr.unshift(值1，值2...)
   
4. 使用 splice() 方法在指定的位置插入一个或多个元素
	array.splice(start[, deleteCount[, item1[, 		item2[, ...]]]])
   arr.splice(位置, 0, 值);
   arr.splice(位置, 0, 值1, 值2 ...)
```

#### 删除元素

```
1. 利用 length 删除数组的后几个元素
   arr.length -= n;  // 删除后n个元素
   
2. 使用 pop() 删除数组最后一个元素
   arr.pop();
   
3. 使用 shift() 删除数组的第一个元素
   arr.shift();
   
4. 使用 splice() 删除指定位置指定数量的元素
   同上
   arr.splice(位置, 要删除的数量)
```

### 多维数组

```js
[
    ['张奶奶', '柳奶奶', '牛那年'], 
    [100, 200, 300, 400, 500], 
    ['刘姥姥', '马姥姥'],
    [
        ['a', 'b', 'c', 'd'],
        ['A', 'B', 'C', 'D'],
    ]
];
```

### 字符串的数组特性

```
字符串与数组有相似的结构，字符串是由字符组成的串，每个字符类似于数组的元素。

字符串具备如下数组特性：
1. 字符串具有 length 属性，可以获取字符串长度（字符串中字符的个数）
2. 使用 [] 指定索引可以读取字符串中的某个字符。
3. 使用 for 循环遍历字符串中的每个字符。

字符串只是具备部分数组的特性：


        1. 字符串无法像数组那样修改其中的某个字符。

        2. 字符串的 length 也不能修改。
```

**浏览器原因**

![image-20210329093019263](TyporaImg/image-20210329093019263.png)



### 伪数组

```
具有length属性 , 不具有数组方法的对象
```



## 函数

### 函数概述

#### ① 什么是函数

* 函数是具有特定功能的代码块。
* 在 JavaScript，函数也是一种数据类型，属于对象类型，使用 typeof 判断函数返回 function。

#### ② 函数作用

* 函数可以被调用多次，提高代码的重用性。
* 可以把整个代码项目，通过函数模块化。
* 封装代码，让函数内部的代码对外部不可见。

#### ③ 函数组成

* 函数名
* 参数
* 函数体
* 返回值



### 函数三种声明方式

#### ① function 关键字方式

```js
function 函数名([参数列表...]) {
 	函数体语句...;   
}
```

#### ② 表达式方式

```js
var 函数名 = function([参数列表...]) {
    函数体语句...;
}
```

#### ③ Function 构造函数方式（了解）

```js
var 函数名 = new Function('函数体语句...');
var 函数名 = new Function('参数1', '参数2', '参数3', '函数体语句...');
var 函数名 = Function('函数体语句...');
var 函数名 = Function('参数1', '参数2', '参数3', '函数体语句...');
```

### 函数的调用和返回值

#### ① 函数调用

* 函数名的后面加括号，才是函数的调用，函数中的语句才可以执行。
* 函数名后面没有括号，函数不会被调用，函数中的语句也不会执行。
* `多个同名函数执行后面的函数`

#### ② 返回值

* 函数调用表达式（函数名+括号）的值是函数的返回值。
* 在函数体内部，使用 return 关键字可以设置返回值，需要在 return 的右边写个表达式（表达式的值就是函数返回值）。

* 如果函数中没有 return 或者 return 的右边没有表达式，函数默认返回 undefined。
* return 关键字除了可以设置函数的返回值，还可以结束函数的执行，执行了 return 之后，函数体内 return 后面的代码就不会执行。

### 函数参数

#### 形参和实参

**形参：** 定义函数的时候所设置的参数，形参就像没有赋值的变量， 形参的形式必须以变量名形式给出。

**实参：** 调用函数给的参数，用于给实参赋值，实参的形式可以是变量、直接量、表达式。

#### 形参和实参的数量问题

1. 设置了多个形参，调用函数的时候就给多少个实参。
2. 如果实参的个数比形参多，实参按照顺序依次给形参赋值，多余的实参就没有用了。
3. 如果实参的个数比形参少，实参按照顺序依次给形参赋值，后面的形参没有对应的实参，默认赋值为 undefined。

#### 形参默认值（可选参数）

**ES5 中给形参设置默认值的方式：**

```js
function 函数名(参数1,参数2) {
    if (参数2 === undefined) {
        参数2 = 默认值;
    }
}
```

**ES6 中给形参设置默认值的方式：**

```js
function 函数名(参数1，参数2=默认值) {
    
}
```

> **注意：** 有默认值的形参一定要放在后面。

#### arguments

1. arguments 只能在函数内使用，arguements 是系统定义好的变量。
2. arguments 可以得到调用函数时给的所有的实参。
3. arguments 是一个类数组（不是真正的的数组），可以通过索引读取其中的成员，具有 length 属性得到长度，可以使用 for 循环遍历里面的成员。
4. JavaScript 函数中获取实参，可以通过设置形参，也可以通过 arguments。

### 作用域

#### 变量作用域

**变量的作用域：** 变量的可作用范围。根据变量的作用域，可以把变量分为**全局变量**和**局部变量**。

**全局变量：** 在函数外边定义的变量就是全局变量，全局变量的作用域是全局。

**局部变量：** 在函数内定义的变量就是局部变量，局部变量的作用域是所在的函数。

> **注意实现：**
>
> 1. 形参是局部变量，作用域是所在的函数。
> 2. 函数名本质上是变量名，所以说函数本身也具有作用域。

#### 作用域链

1. **什么是作用域链：**函数的嵌套可以形成作用域链。
2. **作用域链的作用：** 作用域链描述变量的查找过程。 使用变量的时候，先从本作用域查找有没有声明该变量，如果没有去上层作用域查找，有就停止查找，没有继续向上层作用域查找，一直到全局作用域，如果都没有报错。
3. <font color="red">作用域链只与函数声明的位置有关系，与函数调用的位置无关！</font>



### 变量提升

#### ① 变量提升

JavaScript 中会把变量提升到本作用域的最前面。

只提升了变量的声明，没有提升变量的赋值。

在正式执行代码之前，变量就已经提升了，正式执行到变量声明语句的时候，仅仅是进行赋值操作。

#### ② 函数提升

**function 关键字方式创建的函数：** 不但会提升函数的声明，连同函数一起提升到作用域的最前面。当正式执行代码执行到函数声明语句，直接跳过。

**表达式方式或者 Function 构造函数方式创建的函数：** 与变量提交的规则一致！

#### ③变量/函数提升优先级

```
函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。
```



### 匿名函数

匿名函数就是没有名字的函数； 匿名函数其实就是用直接量方式表示函数。

匿名函数通常作为自调用函数和回调函数使用。

### 自调用函数 

简称 **IIFE**，英文全称 **Immediately Invoked Function Expression**。

自调用函数也叫立即调用的函数，函数声明完立即被调用了。

自调用函数通常会使用匿名函数。

自调用函数的意义： 产生作用域，避免**全局变量污染**。

```js
// 匿名的自调用函数
(function() {
    
})();

// 有名字的自调用函数
(function fn() {
    
})();


// 自调用函数设置参数
(function(name, address) {
    console.log(name + '住在' + address);
})('大悲', '马路上');
```

> **注意：** 连续写多个自调用函数的时候，可能会出现执行错误，需要写完一个自调函数之后用分号结束，或者在自调函数的前面任意写个一元运算符。

![image-20210327115423079](TyporaImg/image-20210327115423079.png)

>   与变量提升结合https://blog.csdn.net/MFWSCQ/article/details/105147732

```
var a = b = 10;

(function(){

var a=b=20			//b在函数内没有赋值,定作全局变量(严格模式下不可以)

})();

console.log(b);
```



### 回调函数

#### ① 什么是回调函数

```
函数作为参数 传递给另一个参数

		并被执行
		
				称....
				
				
作用:解决异步
```

把满足以下三个条件的函数称为回调函数：

1. 函数是我定义的
2. 我没有调用函数（没有直接调用）
3. 函数却被执行了

**注意：** 回调函数的形式大部分都是作为其他函数的参数。

#### ② 回调函数的使用场景

1. DOM事件的回调函数
2. 定时器的回调函数
3. Ajax的回调函数
4. 生命周期的钩子函数
5. 其他需要回调函数作为参数的系统函数（方法）

![image-20210406164536773](TyporaImg/image-20210406164536773.png)

>   回调函数不加括号

### 递归函数

#### ① 什么是递归函数

函数内部可以调用自己，称之为函数的**递归调用**，这种函数叫**递归函数**.

#### ② 递归函数成功的条件

1. 要有结束递归的条件。
2. 随着递归调用次数的增加，应该越来越趋近于递归结束的条件。

#### ③ 递归函数的缺点

1）函数递归调用很容易发生灾难（**内存泄漏**）而调用失败。

2）函数递归调用**效率不高**，能不用就不用。

#### ④ 递归函数应用场景

**后端场景：** 目录的删除、复制、移动等操作。

**前端场景：** 处理从后端获取的 json 数据。

>   锁住卡壳

![image-20210327164937645](TyporaImg/image-20210327164937645.png)

## Object 对象

### 什么是 Object

* Object 是值的无序集合。
* Object 由属性组成，属性有属性名和属性值。
* 属性的值可以是任意类型的数据，属性值如果 function 类型的数据，这种属性可以成为方法。



### 如何声明 Object 对象

#### 直接量方式 { }

```js
// 创建一个空的的对象
var obj1 = {};

// 创建一个带有属性的 object 类型的数据
var obj2 = {
    name: '芳芳', 
    age: 18,
    getInfo: function() {
        console.log('get info 函数');
    },
    users: [100, 200, 300, 400]
};
```

####  Object( )

```js
var obj = Object();
```

#### new Object( )

```js
var obj = new Object();
```

### 属性读写 / 设置

1）`.` 运算符， 如`obj.name`

2）`[]` 运算符，如 `obj['name']`。 属性名要以字符串形式给出，也可以以变量的形式给出。

>   **注意：**
>
>   设置属性值的时候，属性已经存在，就修改属性值；如果属性不存在，就添加属性。 获取对象中不存在的属性的时候，返回 `undefined`
>
>   **注意：**在以下情况下我们必须使用`[]`语法操作：
>
>   ① 如果对象的属性名不符合标识命名规范（变量名的命名规范）。
>
>   ② 如果需要使用变量的值作为属性名。

```js
// 指定属性名，属性名对应的值， 属性名
var data = {
  name:'高育良', 
  age:58, 
  numbers:[100, 200, 300, 400], 
  say: function(){
          console.log('我会说话');
    }, 
  eat: function(){
      console.log('我会吃');
    }
};

// 修改和添加属性
data.name = '大艳艳';   // 使用 . 运算符
data.sex = 'female';
data['numbers'] = [1,2,3,4];  // 使用 [] 运算符

// 读取属性 .
console.log(data.name, data.age);
data.eat();
// 读取属性 可以使用 [], 属性名必须以字符串的形式给出。
console.log(data['age']);
data['say']();

//获取对象中不存在的属性，得到 undefined
console.log(data.length);  // undefined
```



### 属性遍历

`for ... in` 循环可以遍历对象中的属性。

```js
// for in 遍历 Object 所有的属性
for (var prop in obj) {
    console.log(prop, obj[prop]);
}
```



### 删除属性

 delete 运算符，删除对象中的属性。

```
delete 对象.属性名;
delete 对象['属性名'];
```

### 判断存在属性

使用 in 运算符，这是二元运算符，组成的表达式返回布尔值。

```js
'属性名' in 对象
```





![image-20210329201858254](TyporaImg/image-20210329201858254-1617020884120.png)

>   总结:别用关键字





## 构造函数

### 什么是构造函数？

1）对象是一个实际的存在， 构造函数是对对象的描述。

2）对象是构造函数的实例，构造函数是对象的抽象。

3）JS 中的构造函数相当于其他编程语言的**类**（ES6 中也引入了类的概念）。

4）每一对象都有与之对应的构造函数。

5）一个构造函数可以对应很多对象， 一个对象只有一个构造函数。

### 判断对象构造函数

#### ① 运算符 instanceof

判断一个对象是否是某个构造函数的实例，这是一个二元运算符，所组成的表达式的值是布尔值

```js
对象 instanceof 构造函数;
```



#### ② constructor 属性

所有的对象都具有 constructor 属性，通过该属性可以得到对象的构造函数。

```js
对象.constructor
```



### 自定义构造函数

```
// 自定义构造函数
function User(username, pwd, address) {
    // 给对象设置属性
    this.username = username;
    this.pwd = pwd
    this.address = address;

    // 给对象设置方法
    this.getInfo = function() {
        console.log('我叫' + this.username + '，我的密码是' + this.pwd + '，我的地址是' + this.address);
    };
}
```

>   **构造函数特点总结：**
>
>   1. 函数还是构造函数取决于怎么去用，如果实例化就是构造函数，调用就是函数。
>   2. 实例化构造函数的时候，函数中的语句都会被执行到。
>   3. 构造函数函数中的 return 语句对实例化结果的影响：① 如果构造函数没有返回值或者返回原始类型的数据，对实例化结果毫无影响。 ② 如果构造函数返回一个对象类型的数据，实例化的结果就是该返回值。

### 实例化

使用`new` 运算符可以把构造函数实例化成一个对象，不论构造函数是系统内置的还是我们自定义的。

每实例化一个对象，内存中就会开辟一块空间来存储该对象。

```js
//自定义构造函数
function Person() {
}

// 实例化自定义的构造函数
var p = new Person();

// 实例化内置的构造函数
var arr = new Array();
var obj = new Object();
var fn = new Function();
```

### ~与普通函数关系

任何的函数都可以是普通函数，也可以是构造函数，就看我们怎么去使用。

```js
//创建一个类（函数）
function Car(name,color,price){
   this.name = name;
   this.color = color;
   this.price = price;
   this.run = function(){
      console.log('跑的很快~');
   }
}

//普通函数调用
var result = Car('奔驰','black',200000);
console.log(result);

//构造函数调用            
var c1 = new Car('劳斯莱斯','red',10000000);
console.log(c1);
c1.run();
```



## this

### this 的含义

1） this 是 JS **内置**的一个**变量**，本质上是一个**对象**。

2）通常在函数或方法当中使用，代表这个函数的调用者。

### this 的指向

只要省略 点 ,就是window调用



1）在构造函数使用 this， this 指向实例化之后的对象。

2）在方法（所谓函数本质上其实是 window 对象的方法）中使用this，this 指向调用该方法的对象。

>   **注意：**
>
>   在函数中使用 this，this 指向 window 对象。函数本质上其实是 window 对象的方法，所以在函数中使用 this 与第二种情况本质是一样的。

```js
// 在方法中使用this
var obj = {};
obj.name = '曹操';
obj.age = 29;
obj.say = function(){
  console.log('我叫'+this.name+',我今年'+this.age+'岁了');
};
//调用对象的方法
obj.say();   // say 里面的 this 指向 obj。


// 自定义函数（构造函数）
function Dog(name){
  this.name = name;
  console.log(this);
}

//实例化，这么使用 Dog 便是构造函数，里面的 this 指向要实例化成的对象
var d = new Dog('旺财');  

// 调用函数，此时调用改函数的是 window,所以 this 指向window。
Dog('小黄');
4.3 window
```



### **awesome面试题案例**

#### 1. 写出以下程序输出结果

```js
var name = "222";
var a = {
	name: "111",
	say: function () {
		console.log(this.name);
	}
}
var fun = a.say;
fun();		// 
a.say();	//
 
var b = {
	name : "333",
	say: function (func){
		func();
	}
}
b.say(a.say);	//
b.say = a.say;	
b.say();		//
```

#### 2. 写出以下代码输出结果

```js
var foo = 123;
function print(){
    this.foo = 234;
    console.log(foo);
}
print();
```

#### 3 运行`test（）` 和 `new test()` 输出结果分别是什么？

```js
var a = 5;
function test(){
    a = 0;
    console.log(a);//0          0
    console.log(this.a);//5    0/undefined
    var a;
    console.log(a);//0        0
}

```

>   为什么是undefined ? 
>
>   **new出来的实例没有a这个属性**
>
>   好帅这几个题 !

### window 对象

1）window 是浏览器端 JS 的全局对象。

2）打开浏览器，window 对象就会自动生成。

3）所有的全局属性（全局变量和函数）都是 window 对象的属性。

4）使用 window 的属性和方法的时候，通常可以省略window。

5）系统的函数 alert、prompt、Numbe、Boolean、Array、Object等 也是window的属性。



## 原型

感觉有点像java父类

### 概念

* ```
  是对象
    
  
    
    所有对象(实例)都有原型
    
    
    
    实例  *可继承*  原型属性&方法
  ```
  
    

### 获取对象的原型

####  隐式原型

```js
对象.__proto__
```

####  显示原型

```js
对象构造函数.prototype
```

> 两种方式指向同一对象

```js

// 定义一个数组实例
var arr = [10,20,30];

// 实例直接获取 原型
arr.__proto__


// 构造函数获取原型 原型
Array.prototype; 


// 指向同一原型 , 同一对象
arr.__proto__ === Array.prototype
```

### 对象、构造函数、原型关系

* ```
  1） 	对象 == 实例
    
  
    2）	对象(实例)都有原型 	可继承原型的属性。
    
    
    3）   不同实例 构造函数相同 , 其原型相同(也)
  ```
  
    

### 应用

方法定义在实例的原型上，这样可以让构造函数所有的实例化对象**资源共享**

```js
// 自定义构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}


// 给原型添加方法
Person.prototype.say = function(){
  console.log('我是'+this.name+'，我今年'+this.age+'岁了');
};


//实例化对象
var p1 = new Person('曹操', 18);
var p2 = new Person('小乔', 18);
```

### ? 属性属于对象自身 ?

```
对象.hasOwnProperty('属性名')；   

		判断属性是否  属于  实例本身
```

```js
// 自定义构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}


// 给原型添加方法
Person.prototype.say = function(){
  console.log(this); //谁调用了this，this就指向谁。
  console.log('我是'+this.name+'，我今年'+this.age+'岁了');
};


//实例化对象
var p1 = new Person('曹操', 18);


console.log(p1.hasOwnProperty('name'));  // true 自身的属性
console.log(p1.hasOwnProperty('age'));   // true 自身的属性
console.log(p1.hasOwnProperty('say'));   // false 原型上的属性
console.log(p1.hasOwnProperty('constructor'));  // false 原型上的属性
console.log(p1.hasOwnProperty('grade'));  // false 自身和原型都没有的属性
```



### Object.create()

**`Object.create()`**方法创建一个新对象，使用现有的对象来提供新创建的对象的原型. 

另有`Object.difinedProperty/ties`方法 , 只是操作一个对象的属性 , 参见 张培跃ES6课堂笔记笔记 预备知识

>   **语法：**
>
>   ```js
>   Object.create( proto[, propertiesObject])
>   ```
>
>   **参数**：
>
>   -   `proto`
>
>       新创建对象的原型对象。如果该参数是 null，那创建的对象就是一个没有原型的对象。
>
>   -   `propertiesObject`
>
>       可选。如果没有指定为 undefined。否则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。
>
>   **返回值：**
>
>   一个新对象，带着指定的原型对象和属性。

```js
// 在对象的原型上设置方法，并没有改变对象的原型
对象.__proto__.add = function() {
    
};

// 修改了对象的原型的指向
对象.__proto__ = 新的对象;


// 给构造函数实例的原型添加方法，不改变原型的指向
构造函数.prototype.add = function() {
    
}

// 修改构造函数实例的原型的指向
构造函数.prototype = 新的对象;

// 创建对象的同时，指定原型
Object.create(对象);

// 创建一个没有原型的对象
Object.create(null);
```





## 原型链

### 概念

```
*实例* 是 *原型* , *原型* 是 *实例* , 形成一条链子
```

![原型链](TyporaImg/%E5%8E%9F%E5%9E%8B%E9%93%BE1.png)

### 原型链de属性查找

当使用对象中某个属性的时候：

1. 先从自身找
2. 原型找 , 否则undefined

### 图



![原型链](TyporaImg/%E5%8E%9F%E5%9E%8B%E9%93%BE2.jpg)



### 构造函数和原型链

1. ```
    Array() , Number() , String() , 自定义构造函数 , 
    			
    			他们的原型 === Object 实例
    
    -------------------------------------------------------------------------------------------------------------------
    顶层原型
    
    			Object.prototype
    			
    ------------------------------------------------------------------------------------------------------------------
    
    
    原型1.constructor
    
    			指向以 (原型1 作为 原型) 的 (实例) 的构造函数。
    ```

    

>   解释`3`
>
>   ![image-20210413115419963](TyporaImg/image-20210413115419963.png)
>
>   ![image-20210413130615734](TyporaImg/image-20210413130615734.png)
>
>   ![image-20210413130828522](TyporaImg/image-20210413130828522.png)





## 值类型 & 引用类型

### 概念

**原始类型**，也叫**值类型**，还可以被称为**不可变类型**。

**对象类型**，也叫**引用类型**，还可被称为**可变类型**。

### 值类型和引用类型的存储方式

1. 变量和原始类型的数据存储在内容的栈结构中， 对象类型的数据存储到内容的堆结构中。
2. 变量的值如果是原始类型，变量和值都在栈结构中； 如果变量的值是对象类型，对象存在堆结构中，栈结构中存的是变量和对象的地址。
3. 如果变量a赋值给变量b，变量a的值如果是原始类型，直接把值给b。变量a的值如果是对象类型，把地址给b，导致a和b指向的是一个对象。
4. 原始类型的赋值方式成为值传递；对象类型的赋值方式成为引用传递。

![image-20210330150924479](TyporaImg/image-20210330150924479.png)

### 不可变和可变

**不可变类型：** 原始类型的数据，无法修改数据中的一部分，一个原始类型的数据必须作为一个整体。

**可变类型：** 对象类型的数据，可以修改数据中的一部分（修改属性、修改元素）。

### 总结

```
1. 原型
   什么是原型
   如何获取原型
   对象、原型、构造函数之间的关系
   
2. 原型链
   
3. 值类型和引用类型
```





在线文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects

内置构造函数，主要掌握内置构造函数实例的属性和方法

内置对象就是内置构造函数的实例。

## 内置对象

所谓**内置对象**其实就是系统内置的**构造函数**。

### Boolean

创建一个 Boolean 类型的数据，与数组一样也具有三种方式

```js
// 直接量方式
var b1 = true;

// 构造函数方式(具有数据类型转换的功能)
var b2 = new Boolean(true);

// 函数
var b3 = Boolean(false);
```

### Number

#### 实例  属性和方法

| 方法名            | 含义                                             |
| ----------------- | ------------------------------------------------ |
| toFixed([digits]) | 保留指定位数的小数，如果不指定位数就取整，       |
| toString()        | 转为字符串，指定进制，把数字转换为指定的进制形式 |

#### 构造函数  属性和方法

| 属性名           | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| Number.MAX_VALUE | JS可表示的最大数字，是Number构造函数本身的属性，不是数字对象的属性！！ |
| Number.MIN_VALUE | JS可表示的最小数字，是Number构造函数本身的属性，不是数字对象的属性！！ |





### String

#### 实例  属性和方法

| 方法名                                               | 含义                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| length                                               | 串长度                                                       |
| indexOf()                                            | 返回字符串/字符在某个字符串第一次出现的位置 没有-1           |
| lastIndexOf()                                        | 返回字符串/字符在某个字符串最后一次出现的位置 没有-1         |
| ——slice(start, end)                                  | 截取字符串，指定开始索引和结束索引，结束索引不会被截取到，第二个参数可以省略（截取到最后） |
| ——substring(start, end)                              | 同上                                                         |
| ——substr(start, lenth)  (废弃 , 尽量用substring代替) | 截取字符串，指定开始索引和截取长度； 第二个参数可以省略（截取到最后） |
| split()                                              | 把字符串分割为数组，可以指定分隔符                           |
| toUpperCase()                                        | 字符串转为大写                                               |
| toLowerCase()                                        | 字符串转为小写                                               |
| chatCodeAt()                                         | 返回指定位置字符的unicode字符码                              |
| String.fromCharCode()                                | 根据unicode编码生成指定字符 （不是字符串对象的方法，是String构造函数的方法） |
| search(regexp)                                       | 查找字符串 可用于正则匹配                                    |
| match(regexp)                                        | 匹配字符串 可用于正则匹配                                    |
| replace(regexp/substr, newSubStr/function)           | 替换字符串 可用于正则替换                                    |

> **注意：**
>
> 1. 通常可以使用 indexOf() 和 lastIndexOf() 来判断字符串中是否包含某个值，返回 -1 就是不包含。
> 2. 字符串实例的 charCodeAt() 方法和 String 构造函数本身的 fromCharCode() 方法互为逆向操作。

#### 构造函数  属性和方法

```
String.fromCharCode(数字编码)		返回指定 unicode 编码对应的字符
```

#### 转换驼峰命名

**正则**

```js
函数接受一个字符串作为参数，可以把类似于 is_good_name 这样的变量名替换成 isGoodName。变量名首尾的下划线不需要做处理，中间的下划线全部删除并且处理成驼峰。
```

```js
			(function () {
				const toCamelCaseVar = (variable) => {
                    //可以改变-,_
					let reg = /-+(\w)/g;
					let str = variable.replace(reg, function () {
						if (arguments[2]) return arguments[1].toUpperCase();
						else return arguments[0];
					});
					return str;
				};
                var arr = toCamelCaseVar("get-element-by-id");
                console.log(arr);

			})();
```

**my函数**

```js
			function toCamelCaseVar(string) {
				var strArr = string.split('-'); //["get", "element", "by", "id"]
				//  console.log(strArr);
				//分成若干字符串数组
				var strSet = '';
				for (var i = 0; i < strArr.length; i++) {
					if (i > 0) {
						var temp = strArr[i].split(''); //['G','e','t'] ---> 'Get'
						//  console.log(temp);
						var firstUpper = temp[0].toUpperCase();
						temp.splice(0, 1, firstUpper);
						temp = temp.join(''); ////'Get'
						// console.log(temp);
						strSet += temp;
					} else {
						strSet += strArr[i];
					}
				}
				// console.log(strSet);
				return strSet;
			}
```

**铭哥**

```js
return item[0].toUpperCase() + item.slice(1);
```

![image-20210401094336500](TyporaImg/image-20210401094336500.png)

### Math

#### 属性

| 属性名  | 含义       |
| ------- | ---------- |
| Math.PI | 返回圆周率 |

#### 方法

| 方法名                  | 含义                                                     |
| ----------------------- | -------------------------------------------------------- |
| Math.abs(x)             | 求绝对值                                                 |
| Math.sqrt(x)            | 求平方根                                                 |
| Math.pow(x,y)           | 求 x 的 y 次幂                                           |
| Math.max([x[, y[, …]]]) | 返回参数里面最大的值                                     |
| Math.min([x[, y[, …]]]) | 返回参数里面最小的值                                     |
| Math.round(x)           | 四舍五入取整                                             |
| Math.floor(x)           | 向下取整                                                 |
| Math.ceil(x)            | 向上取整                                                 |
| Math.random()           | 返回一个 0 到 1 之间的伪随机数，但是不包括 1（左闭右开） |

> **取随机数的规则：**
>
> 1. 随机取 0 ~ n 之间的整数： `Math.floor(Math.random() * (n + 1))`
> 2. 随机取 s ~ n 之间的整数： `Math.floor(Math.random() * (n - s + 1)) + s`

### Date

#### 创建 date 对象

```js
var today = new Date();
new Date();
new Date(value);
new Date(dateString);
new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);
```

#### 实例  属性和方法

| 方法名                                                       | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Date.now()                                                   | 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数。 |
| Date.UTC()                                                   | 返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。 `Date.UTC(year,month[,date[,hrs[,min[,sec[,ms]]]]])` |
| getYear()                                                    | 根据特定日期返回年份 (通常 2-3 位数)，不推荐使用             |
| getFullYear()                                                | 根据本地时间返回指定日期对象的年份（四位数年份时返回四位数字）。 |
| getMonths()                                                  | 根据本地时间返回指定日期对象的月份（0-11）。                 |
| getDay()                                                     | 根据本地时间返回指定日期对象的星期中的第几天（0-6）。        |
| getDate()                                                    | 根据本地时间返回指定日期对象的月份中的第几天（1-31）。       |
| getHours()                                                   | 根据本地时间返回指定日期对象的小时（0-23）。                 |
| getMinutes()                                                 | 根据本地时间返回指定日期对象的分钟（0-59）。                 |
| getSeconds()                                                 | 根据本地时间返回指定日期对象的秒数（0-59）。                 |
| getMilliseconds()                                            | 根据本地时间返回指定日期对象的毫秒（0-999）。                |
| getUTCYear() getUTCFullYear() getUTCMonth() getUTC... ...    | 根据世界时返回特定日期对象所在的年、月、日、时、分、秒。     |
| getTime()                                                    | 返回从1970-1-1 00:00:00 UTC（协调世界时）到该日期经过的毫秒数，对于1970-1-1 00:00:00 UTC之前的时间返回负值。 |
| getTimezoneOffset()                                          | 返回当前时区的时区偏移。                                     |
| setYear() setFullYear() setMonth() ... setTime() ... setUTCYear() setUTCFullYear() setUTC... ... | 设置 Date 对象中年、月、日、时                               |



#### 构造函数  属性和方法

```

Date.now()				此时此刻的时间戳

Date.UTC()				指定日期时间的时间戳，需要设置 6 个参数。
```

#### 日期格式化

将日期转换为指定的格式：比如转换成 年月日时分秒 这种格式：yyyy-MM-dd hh:mm:ss 或者 yyyy-MM-dd

**可以为Date原型添加如下的方法：**

```js
Date.prototype.format = function(fmt) { 
     var o = { 
        "M+" : this.getMonth()+1,                 //月份 
        "d+" : this.getDate(),                    //日 
        "h+" : this.getHours(),                   //小时 
        "m+" : this.getMinutes(),                 //分 
        "s+" : this.getSeconds(),                 //秒 
        "q+" : Math.floor((this.getMonth()+3)/3), //季度 
        "S"  : this.getMilliseconds()             //毫秒 
    }; 
    if(/(y+)/.test(fmt)) {
            fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); 
    }
     for(var k in o) {
        if(new RegExp("("+ k +")").test(fmt)){
             fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));
         }
     }
    return fmt; 
}      
————————————————
版权声明：本文为CSDN博主「qq_39985511」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_39985511/article/details/80031674
```

比如我们可以这样调用下：

var time1 = new Date().format("yyyy-MM-dd hh:mm:ss");
console.log(time1);

运行如下：

![img](TyporaImg/082121235999016.png)



也可以转换成 ”年月日”的格式 

var time2 = new Date().format("yyyy-MM-dd");
console.log(time2);

运行如下：

![img](TyporaImg/082122201143518.png)





2. 将指定的日期转换为"年月日"的格式，代码如下：

    var oldTime = (new Date("2012/12/25 20:11:11")).getTime();
    var curTime = new Date(oldTime).format("yyyy-MM-dd");
    console.log(curTime);

   运行如下
   
   ![img](TyporaImg/082125251452423.png)
   
   **3. 将 \**"时间戳"\** 转换为 \**"年月日"\** 的格式.**
   
    比如如下代码： 

```js
var da = 1402233166999;
    da = new Date(da);
    var year = da.getFullYear()+'年';
    var month = da.getMonth()+1+'月';
    var date = da.getDate()+'日';
    console.log([year,month,date].join('-'));

原文链接：https://blog.csdn.net/qq_39985511/article/details/80031674
```

![img](TyporaImg/082127454582991.png)

>   自己栗子
>
>   ```js
>               var curT = new Date().format('yyyy-MM-dd hh:mm:ss');
>   ```

### Array

只有数组有修改器方法

#### 访问方法(本身不改 , 返回结果)

下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。

| 方法名                                    | 含义                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| concat(value1[, value2[, ...[, valueN]]]) | 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 |
| slice([begin[, end]])                     | 抽取当前数组中的一段元素组合成一个新数组，数组截取。         |
| join([separator])                         | 连接所有数组元素组成一个字符串。                             |

>   连接,截取,合并

#### 修改方法(本身修改)

下面的这些方法会改变调用它们的对象自身的值。

| 方法名                                                | 含义                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| push(element1, ..., elementN)                         | 在数组的末尾增加一个或多个元素，并返回数组的新长度。         |
| pop()                                                 | 删除数组的最后一个元素，并返回这个元素。                     |
| unshift(element1, ..., elementN)                      | 在数组的开头增加一个或多个元素，并返回数组的新长度。         |
| shift()                                               | 删除数组的第一个元素，并返回这个元素。                       |
| splice(start[, deleteCount[, item1[, item2[, ...]]]]) | 在任意的位置给数组添加或删除任意个元素。                     |
| reverse()                                             | 颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 |
| sort([compareFunction])                               | 对数组元素进行排序，并返回当前数组。                         |

#### ES5   方法(本身不修改,返回结果)

(也可以没有返回结果)

这些方法也都是访问器方法！都需要回调函数作为参数。

| 方法名                                                       | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| forEach(callback[, thisArg])                                 | 为数组中的每个元素执行一次回调函数，用于数组遍历             |
| filter(callback[, thisArg])                                  | 将所有在过滤函数中返回 `true` 的数组元素放进一个新数组中并返回，用于数组过滤。 |
| map(callback[, thisArg])                                     | 返回一个由回调函数的返回值组成的新数组。                     |
| every(callback[, thisArg])                                   | 如果数组中的每个元素都满足测试函数，则返回 `true`，否则返回 `false。` |
| some(callback[, thisArg])                                    | 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 |
| reduce(callback:((accumulator,item,index,arr))[, initialValue]) | 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 |
| reduceRight(callback[, initialValue])                        | 从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 |
| indexOf(searchElement[, fromIndex])                          | 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 |
| lastIndexOf(searchElement[, fromIndex])                      | 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 |

```
forEach(item,index)			用于遍历,无返回值
filter(item,index)			返回true才返回item对象
                    
map()				return什么,就替换为什么
every()				返回布尔值，要求每个元素的回调函数都返回true才得到true，需要一个回调函数作为参数。
some()				返回布尔值，只要一个元素的回调函数返回true就得到true，需要一个回调函数作为参数。
reduce()			用于综合计算，参数:  回调函数，初始值

                    				   回调函数三个参数：(1)上一次回调的结果 (2)当前的元素 (3) 索引

reduceRight()		同 reduce 一样，知识从后向前遍历。

indexOf()			返回指定元素在数组中第一次出现的位置。

lastIndexOf()		返回指定元素在数组中最后一次出现的位置。
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 定义数组
        var users = [
            {
                name: '芳芳',
                age: 18,
                address: '上海'
            },
            {
                name: '大悲',
                age: 78,
                address: '山洞'
            },
            {
                name: '曹操',
                age: 48,
                address: '许昌'
            },
            {
                name: '吕布',
                age: 38,
                address: '包头'
            },
            {
                name: '曹丕',
                age: 12,
                address: '许昌'
            },
            {
                name: '小悲',
                age: 31,
                address: '山洞'
            }
        ];


        console.log(users);
        console.log('');


        // forEach 遍历数组
        users.forEach(function(item, index) {
            console.log(item, index);
        });
        console.log('');


        // filter 获取用户中的成年人
        var fUsers = users.filter(function(item, index) {
            return item.age >= 18;
        });
        console.log(fUsers);
        console.log('');


        // map 从原数组提取信息 得到新数组，年龄+1
        var mUsers = users.map(function(item, index) {
            // return item.name;
            item.age ++;
            return item;
        });
        console.log(mUsers);
        console.log('');



        // 是否所有的用户都是成年人
        var res = users.every(function(item, index) {
           return item.age >= 18;
        });
        console.log(res);
        console.log('');


        // 是否有用户住在山洞
        var res = users.some(function(item, index) {
            return item.address === '山洞';
        });
        console.log(true);
        console.log('');



        // reduce
        var nums = [100,200,300,400];
        //使用 reduce 计算nums所有元素的和
        var sum = nums.reduce(function(prev, item, index) {
            return prev + item;
        }, 0);
        console.log(sum);
        console.log('');

        // users，计算所有用户的年龄和
        var ageSum = users.reduce(function(prev, item) {
            return prev + item.age;
        }, 0);
        console.log(ageSum);

        // users.reduceRight()
        console.log('');


        // indexOf() lastIndexOf()
        console.log(nums.indexOf(400));
        console.log(nums.indexOf(4000));




    </script>
</body>
</html>
```

#### 其它方法

##### find

![image-20210423182841908](TyporaImg/image-20210423182841908.png)

##### findIndex

查找第一个满足条件的元素索引

```
findIndex((item , index , thisArr) => {

} , [this])
```



##### filter

>   与find不同的是 , 
>
>   filter返回所有满足条件的元素
>
>   ```
>   JQuery也有此方法
>   ```

### String/Arry

相同方法

```
length
slice()
indexOf()
lastIndexOf()
```

### Function

#### 实例  属性和方法:

```
length									   获取函数所需参数的个数

call(对象[,param[,param])			 		 调用函数并指定函数内this的指向，一参:this指向 , 二参等:函数的参数

apply(对象,[param,param,param,....])       调用函数并指定函数内this的指向，一参:this指向 , 二参:数组,存着 函数的参数

bind(对象,[,param[,param]])				 不调用 ,返回修改了this指向的新函数。(使用场景如下)
```

![image-20210417112823711](TyporaImg/image-20210417112823711.png)

> **1. call 和 applay 的区别？**
>
> 传参方式不同。
>
> **2. call 和 bind 区别？**
>
> call() 会把函数调用了，bind() 返回新函数（不会调用）

```js
        // call
        // 直接fn
        fn('芳芳', 19);
        console.log('');

        // 函数本身调用 call 方法，把函数自己调用了
        fn.call();
        console.log('');

        // call 可以把函数给调用， 设置函数内this的指向
        fn.call([100,200], '大悲', 90);
        console.log('');
        console.log('');


        // applay  与 call 一样
        fn.apply(100, ['小悲', 89]);
        console.log('');
        console.log('');
        console.log('');




        // 定义字符串
        var msg = 'hello world';
        // 把字符串中的字符遍历出来
        [].forEach.call(msg, function(item, index) {
            console.log(item, index);
        });
        console.log('');
        console.log('');


        // 定义数组
        var nums = [123, 456, 890, 654, 89, 235, 78];
        // 获取数组中最大的元素
        console.log(Math.max.apply({}, nums));
        /// 获取数组中最小的元素
        console.log(Math.min.apply({}, nums));

```

```js
        // 定义函数
        function fn(name, age) {
            console.log(this);
            console.log('参数：', name, age);
        }

        fn('芳芳', 17);
        console.log('');

        var fn1 = fn.bind({name:'曹操'});
        fn1('大悲', 92);
        console.log('');


        var fn2 = fn.bind(100, '芳芳');
        fn2(20);

        // 函数柯里化
```

### JSON

| 方法名           | 含义                           |
| ---------------- | ------------------------------ |
| JSON.parse()     | 解析JSON字符串并返回对应的值。 |
| JSON.stringify() | 返回与指定值对应的JSON字符串。 |

#### 解释json

json 是对象形式的字符串

1）json（ JavaScript Object Notation）是一种前后端数据交互的数据格式。`js对象标记`

2）json本质上是一个字符串，简称json串

```js
{
  "paramz": {
    "feeds": [
      {
        "id": 299076,
        "oid": 288340,
        "category": "article",
        "data": {
          "subject": "汉东新闻2.0：不止是阅读",
          "summary": "汉东广电旗下资讯类手机应用“汉东新闻”于近期推出全新升级换代的2.0版。",
          "cover": "/Attachs/Article/288340/3e8e2c397c70469f8845fad73aa38165_padmini.JPG",
          "pic": "",
          "format": "txt",
          "changed": "2019-09-22 10:01:42"
        }
      }
    ],
    "PageIndex": 1,
    "PageSize": 20,
    "TotalCount": 53521,
    "TotalPage": 2677
  }
}
```

>   **注意：**
>
>   json 格式参照 JavaScript `对象`、`数组`的语法，但有些不同，如 ：
>
>   ① json 中属性名称必须是双引号括起来的字符串，最后一个属性后不能有逗号。
>
>   ② json 中字符串必须用双引号括起来。

### 全局函数

全局对象的方法

**全局对象 （global object）** 是可以在全局作用域里，通过this访问（但只有在 ECMAScript 5 的非严格模式下才可以，在严格模式下得到的是 undefined）。在浏览器端，全局对象就是 window 对象。

**全局的对象**（ global objects ）或称标准内置对象，不要和 **"全局对象**（global object）**"** 混淆。这里说的全局的对象指的是**全局对象的属性**。全局对象的属性都在**全局作用域中**。

#### 属性

| 属性名   | 含义                                 |
| -------- | ------------------------------------ |
| NaN      | 一个 number 类型的值，Not-A-Number。 |
| Infinite | 一个number类型的值，表示无穷大。     |

#### 方法

| 方法名       | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| eval(string) | 会将传入的字符串当做 JavaScript 代码进行执行。               |
| encodeURI()  | 通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 |
| decodeURI()  | 函数能解码由 encodeURI() 创建或其它流程得到的统一资源标识符（URI） |
| isNaN()      | 确定一个值是否为 NaN。                                       |
| isFinite()   | 判断一个数是否是有限数值。                                   |
| parseInt()   | 从字符串中提取整数。                                         |
| parseFloat() | 从字符串中提取浮点数。                                       |

## BOM

### window

#### 弹框

```js
// 警告弹框   方法没有返回值
alert('警告框');

// 确认弹框   方法返回布尔值
var res = confirm('你确定吗？');

// 输入弹框   方法返回输入的内容
prompt('请输入您的银行卡密码：');
```

#### 打开新窗

新标签页或iframe(指定名称)

```js
// 新标签页打开页面
window.open('页面地址');

// 打开空白的新标签页
window.open('');

// 在窗口打开新页面
window.open('页面地址', window.name);

// 打开新窗口并指定窗口的宽高
window.open('页面地址', '', 'width=600,height=400');

// 关闭窗口  只有 open 打开的窗口，chrome才允许使用 close 关闭。
window.close()

// 调用浏览器的打印机接口
window.print();
```

#### 页面滚动

直接传参,或对象

```js
// 滚动到指定位置（页面顶部）
window.scrollTo(0, 0);

// 滚动到指定位置（页面顶部）带有效果
window.scrollTo({
    top: 0,
    behavior: 'smooth'
});

// 指定滚动多少距离  向右滚动100px，向下滚200px
window.scrollBy(100, 200);

// 指定滚动多少距离，带有效果
window.scrollBy({
    left:0, 
    top: 200,
    behavior: 'smooth'
});
```

#### 定时器

**多次定时**

```js
// 开启多次定时
setInterval(function() {
    console.log('hello 芳芳');
}, 2000);


// 开启定时器
setInterval(run, 3000);
function run() {
    var r = Math.floor(Math.random() * 256);
    var g = Math.floor(Math.random() * 256);
    var b = Math.floor(Math.random() * 256);
    document.body.style.backgroundColor = 'rgb('+r+','+g+','+b+')';
}


// 开启定时器 返回定时器标识
var intervalId = setInterval(function() {
    // 数字累减
    num --;
    // 设置 box 元素中的内容
    boxNode.innerHTML = num;
    // 判断如果 num 值变为 0，停止定时器
    if (num <= 0) {
        clearInterval(intervalId);
    }
}, 1000);
```

>   停止定时器,标记变量不变

**单次定时：**

```js
// 开启单次定时
setTimeout(function() {
   
}, 2000);

// 开启单次定时，返回定时器标识符
var timeoutId = setTimeout(runTime, 2000);
function runTime() {
    
}

// 停止单次定时, 指定定时器标识符
clearTimeout(timeoutId)
```

#### window 对象属性和方法总结

```
属性：

name				设置或获取本窗口的名字
length				获取子窗口的数量（一个 iframe 就是一个子窗口）
innerWidth			获取视口的宽度
innerHeight 		获取视口的高度
document
locaiton
history
navigator
screen

方法：

alert()				警告框
confirm()			确认框
prompt()			输入框
open()				打开新窗口
close()				关闭窗口
print()				调用打印接口
scrollTo()			滚动到指定位置
scrollBy()			滚动多少距离
setInterval()		开启多次定时
clearInterval()		停止多次定时
setTimeout()		开启单次定时
clearTimeout()  	停止单次定时
```

### history

history 描述**本窗口**的历史记录。

```
length		属性，获取本窗口历史记录的条数
back()		跳转到历史记录中的上一页
forward()	跳转到历史记录中的下一页
go(n)		跳转到前n页或后n页，n是数字，正数是后n页，负数是前n页
```

### location

location 对象描述当前窗口的地址（URL）信息。

```
属性：
href		获取或设置本窗口完整的URL信息

protocol	获取或设置URL中的协议信息

hostname	获取或设置URL中的主机名

port		获取或设置URL中的端口号(就是哪个程序)

host		获取或设置URL中的主机名+端口号

pathname	获取或设置URL中路径布局(访问的文件路径)

search		获取或设置URL中的搜索字符串

hash		获取或设置URL中的锚点部分

方法：
reload()	刷新本页面
assign(url)	跳转到指定页面
repalce(url)跳转到指定页面，会把原页面在历史记录中删除
```

`protocol :// host [:port] / path / [?query]#fragment`



### navigator

navigator 对象用于描述浏览器的版本信息、内核信息以及操作系统的部分信息。

```
userAgent		获取客户端浏览器的信息
```

### screen

screen 对象描述屏幕相关的信息。

```
width	获取屏幕的宽度
height  获取屏幕的高度
```



## *DOM**

### 介绍

**<font color="red">MDN 文档对象模型手册</font>：**https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model

1）DOM 英文全称“Document Object Model”，译为“文档对象模型”。

2）DOM 是一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式。

### Node 节点

#### 5 节点类型

```
document 文档节点 nodeType:9
element	元素节点 nodeType:1  nodeName 获取元素的标签名
attribute 属性节点 nodeType:2
text 文本节点 nodeType:3
comment 注释节点 nodeType:8
```

#### 属性

```
nodeName		获取节点名字
nodeValue		获取节点值
nodeType		获取节点类型，用数字表示
```



### 获取元素

#### ① 通过 ID 名

```js
document.getElementById('ID名');
```

> **总结：**
>
> 1. 返回元素对象
> 2. 如果没有满足条件的元素返回 null。
> 3. id选择器可以不获取,直接用,但变量名为id

#### ② 通过标签名

```js
// 从文档中获取
document.getElementsByTagName('标签名');

// 从元素的后代中获取
element.getElementsByTagName('标签名');
```

> **总结：**
>
> 1. 返回HTMLCollection 对象，这是一个伪数组对象，成员是元素对象。
> 2. 如果没有满足条件的元素，返回空的集合。
> 3. 没说可以使用`forEach()`

#### ③ 通过类名（了解，IE8 + 支持）

```js
// 从文档中获取
document.getElementByClassName('类名');

// 从元素的后代中获取
element.getElementsByClassName('类名');
```

> **总结：**
>
> 1. 返回 HTMLCollection 对象，这是一个伪数组对象，成员是元素对象。
> 2. 如果没有满足条件的元素，返回空的集合。

#### ④ 通过 name 属性值 （了解）

```js
// 从文档中获取
document.getElementsByName('name属性的值');
```

> **总结：**
>
> 1. 返回NodeList对象，与 HTMLCollection 相似，也是`伪数组`(但可以使用`forEach()`方法，里面的元素是元素对象。
> 2. 如果没有满足条件的元素，返回空集合。

#### ⑤ 使用选择器获取元素 (推荐)

```js
// 从文档中获取
document.querySelector('选择器')；
document.querySelectorAll('选择器');

// 从元素的后代中获取
element.querySelector('选择器');
element.querySelectorAll('选择器');
```

> **总结：**
>
> 1. querySelector() 方法返回一个元素对象，如果满足条件的元素有多个只取第一个，如果没有满足条件的元素返回 null。
> 2. 返回 NodeList 集合，如果没有满足条件的元素返回空集合。

#### ⑥ 获取所有/其它元素

```js
document.all

document.啥啥啥啥(下面document标题里)

```

> **总结：** 获取文档中所有的元素，返回 HTMLCollection 类型的集合

> **注意：**使用 document.all 可以判断IE还是非IE，这是一个语法糖。
>
> ```js
> if (document.all) {
>  document.write('我是IE浏览器！');
> } else {
>  document.write('我不是IE');
> }
> ```



### 元素关系

#### 节点树

```
childNodes		获取所有子节点的集合，是个 NodeList 类型的对象
firstChild		获取第一个子节点
lastChild		获取最后一个子节点

previousSibling	获取紧邻在前面的兄弟节点
nextSibling		获取紧邻在后面的兄弟节点

parentNode		获取父节点
```

>   返回节点类型

#### 元素树

```
children				获取所有子元素的集合，是个 HTMLCollection 类型的数据
firstElementChild		获取第一个子元素
lastElementChild		获取最后一个子元素

previousElementSibling	获取紧邻在前面的兄弟元素
nextElementSibling		获取紧邻在后面的兄弟元素

parentElement			获取父元素
```

>   返回元素类型



### 元素属性操作

#### 读设内置属性

```js
元素.属性名;
```

>   可读可设,没有则添加

#### 读设自定义属性

```
元素.getAttribute('属性名')		 读取属性的值，如果不存在概述返回 nulll
元素.setAttribute('属性名', '值')  设置属性的值，如果属性不存在会添加该属性
```

> **注意：** 
>
> 1. getAttribute() 和 setAttribute() 可以操作写在标签上的所有属性，不论内置的还是自定义的。
> 2. 如果要操作的属性是内置，使用 `.属性名` 的方式；如果要操作的属性是自定义的再使用 getAttribute() 和 setAttribute()。
> 3. 返回字符串(始终)

#### `data-*` 形式的自定义属性

HTML5标准建议标签中的自定义属性都是 `data-message` 、`data-group-name` 这样的形式，此种形式的自定义属性，DOM 提供了快捷的操作方式：

```js
元素.dataset.属性名;  // 可读可设

imgEle.dataset.message;  // 对应的是 data-messag 属性
imgEle.dataset.gorupName; // 对应的是 data-group-name 属性
```

>   dateset.
>
>   小驼峰
>
>   可读可设 , 没有则添加

>   `读设`都用`dataset.属性名`设置
>
>   `显示`都用`data-属性名`显示

![image-20210409104637111](TyporaImg/image-20210409104637111.png)

### 元素样式操作



#### 行内样式读写

```js
元素.style.属性名;
元素.style.['属性' 或 [变量]]
```

> **注意：**
>
> 1. 该方式只能读取设置在行内的样式，设置也是把样式设置到行内。
> 2. 如果CSS属性名中有 `-` 会自动映射为小驼峰的形式，如果 `backgorund-color` 映射为 `backgroundColor`

#### 计算样式读写

```js
getComputedStyle(元素).属性名;
					  或 ['属性'[变量]]
```

```js
 /**
  * 封装读取计算样式的函数
 */
function getStyle(ele, attr) {
    // 判断
    if (window.getComputedStyle) {
        // ie 8 不支持
        return getComputedStyle(ele)[attr];
    } else if (ele.currentStyle) {
        //  IE8 支持
        return ele.currentStyle[attr];
    }
}
```

> **注意：**该方式只能读取。



#### 类名操作样式

##### ① className

```js
元素.className;  // 可读可写
```

> **返回字符串** , 可用indexOf( )判断是否存在类

##### ② classList

```js
元素.classList;   // 得到描述元素类名的对象，是所有类名组成的集合，是个伪数组

// classList 对象具有以下三个方法：
元素.classList.add('类名');   // 给元素添加一个类名
元素.classList.remove('类名');  // 删除一个类名
元素.classList.toggle('类名');   // 类名切换（如果元素有该类名就删除，没有该类名就添加）
```

>   返回集合 , 伪数组



### 读写元素文本内容（可读可写）

```
innerHTML		读写元素中所有内容（包括内部html标签）
outerHTML		读写元素含自己的所有代码内容（包括自己标签代码）


innerText		读写元素内的文内容（不包括html标签）（只保留换行）
textContent		读写元素内的文内容（不包括html标签），保留原格式（缩进和换行）
```



### 元素宽高（只读）

>   6 组
>
>   2组含边框
>
>   2组不含边框
>
>   2 组视口宽高

```
offsetWidth				盒子宽度（含边框）
offsetHeight            盒子高度（含边框）


	
clientWidth				宽度（不含边框）(用于儿子活动范围)
clientHeight			高度（不含边框）



scrollWidth				宽度(内容不溢出,不含边框)
scrollHeight 			高度(内容溢出,加上溢出内容,不含边框)



getBoundingClientRect()
					.width/height            与 offsetWidth/offsetHeight 一致
```



#### **视口宽高**

```js
//  包含滚动条        第一种方式 
window.innerWidth;
window.innerHeight;

//  排除滚动条		   第二种方式 
document.documentElement.clientWidth
document.documentElement.clientHeight
```

>   document.documentElement.clientWidth/Height **语法糖**   (非html宽高 , 而视口宽高)

### 元素位置 （只读）

>   2组

```
    offsetLeft		元素位置				(包含块相对)
    offsetTop       元素位置				(包含块相对)



getBoundingClientRect() 返回一个对象，有如下属性
	
	x			    元素位置				(包含块相对)
	y			    元素位置				(包含块相对)
	
	------------------------------------------------------------------------
	
	left			元素位置 				(视口相对)
	top				元素位置 				(视口相对)
	right			元素位置(右下角)	 	  (视口相对)
	bottom			元素位置(右下角) 		  (视口相对)

```

>   元素位置分类:
>
>   4个包含块;
>
>   offsetLeft/offsetTop/gBCR().x/y
>
>   4个视口:
>
>   gBCR().left/right/top/bottom





>   ```
>clientLeft		元素左边框宽度
>   clientTop		元素上边框宽度
>```
>   
>不能通过clientLeft/clientTop获取元素位置 , 没有边框的元素位置有啥意义 ? 



### 元素溢出内容位置（可读可写）

>   必须设置父元素**overflow**不可见(hidden,auto,皆可)

```
scrollLeft		左边溢出内容----不用单位
scrollTop		右边溢出内容----不用单位
```

>   页面滚动溢出距离
>
>   通过以下:

```
document.documentElement.scrollTop   

-----------------------------------------

兼容写法

document.documentElement.scrollTop || document.body.scrollTop

-----------------------------------------

新方法(i9)

window.pageYOffset/XOffset
```



### 元素创建/添加/删除/替换/克隆

#### 创建元素节点

```js
document.createElement('标签名');  // 返回创建好的元素
```

#### 添加子节点

##### ① 在最后面添加子节点

```js
父元素.appendChild(新节点);
```

##### ② 指定位置添加子节点

```js
父元素.insertBefore(新节点, 旧节点)
```

> **注意：** 新的节点会在旧节点的前面！

#### 删除子节点

```js
父元素.removeChild(要删除的节点);
```

#### 替换子节点

```js
父元素.replaceChild(新节点, 旧节点);
```

#### 克隆节点

```js
元素.cloneNode(true)
```

> false:浅克隆
>
> true:深克隆





### documnt

```
属性:

lastModified		获取文档最后一次修改时间，只读
cookie				读写cookie信息，可读可写
all					获取文档中所有的元素，HTMLCollection，只读
documentElement		获取html元素，只读
body				获取body元素，只读
head				获取head元素，只读


title				读写页面标题 (字符串) ，可读可写

方法:

write()				把内容写入文档
```





### documentFragment

#### 创建

```
document.createDocumentFragment();
```

#### 特点

1）documentFragment 也是一类节点， nodeType 是 11，并不是元素对象，它通常作为其他节点的一个临时的容器。

2）documentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。

#### 应用

**1）减少渲染次数**

如果连续给一个元素添加多个子元素，可以先把子元素添加到 documentFragment 对象中，最后把 documentFragment 对象添加到父元素中，减少浏览器渲染次数。

**2）倒序排列**

利用 documentFragment , appendChild , insertBefore 实现对一组元素进行倒序排列。

```html
    <script>
        // 创建一个 documentFragment 对象
        var df = document.createDocumentFragment();
        console.log(df);
        console.log('nodeName：', df.nodeName);
        console.log('nodeValue：', df.nodeValue);
        console.log('nodeType：', df.nodeType);
        
        
        // 获取相关元素
        var ulBox = document.querySelector('#box');
        var addBtn = document.querySelector('#addBtn');
        var reverseBtn = document.querySelector('#reverseBtn');

        // 定义数组
        var userList = ['刘奶奶', '欧阳奶奶', '姑奶奶', '少奶奶', '二少奶奶', '三少奶奶'];

        // 添加 批量创建并添加 li
        addBtn.onclick = function() {
            // 创建一个 documentFragment 对象
            var df = document.createDocumentFragment();

            // 遍历数组， 创建li 并添加
            userList.forEach(function(item) {
                // 创建新的 li
                var liBox = document.createElement('li');
                // 设置li的文本内容
                liBox.innerHTML = item;
                // 把 li 添加到 df 中
                df.appendChild(liBox);
            });

            // 让dr作为一个子节点，添加到 ul 中
            ulBox.appendChild(df);
        }

        // 翻转元素
        reverseBtn.onclick = function() {
            // 获取所有的 li
            var liBoxs = document.querySelectorAll('#box li');

            // 创建 df 对象
            var df = document.createDocumentFragment();

            // 遍历所有li，从后向前遍历，一次添加到 df 中
            for (var i = liBoxs.length - 1; i >= 0; i --) {
                df.appendChild(liBoxs[i]);
            }

            // 把 df 加入 ul
            ulBox.appendChild(df);
        }




    </script>
```



## DOM(表单/格/图片)



### 表单相关元素

#### form 元素

```
submit()		表单提交
reset()			表单重置
```

#### 文本输入框和文本域（input 和 textarea）

```
blur()		失去焦点
focus()		获取焦点
select()	选中里面文本
```

#### select 下拉框

```
属性:



        length			（可读可写）下拉选项数量
        
        options			所有下拉选项集合
        
        selectedIndex	所选下拉选项索引
        
        value			获取所选下拉选项value值



方法:

        add( new Option(xx , xx) )			添加一个下拉选项
        remove( index )						删除一个下拉选项
        blur()								失去焦点
        focus()								获取焦点
```

> **注意：**
>
> `new Option( [文本内容,value值] )`   快速创建一个 option 元素，第一个参数指定下拉选项的文本内容，第二个参数指定下拉选项的value值。

### 表格相关元素

#### ① table 元素

```
属性:

    rows		表格中所有行元素集合

    cells		表格中所有单元格元素集合

方法:

    insertRow()			插入一行

    deleteRow()			删除一行
```

>   th 和 tr 算同类型

#### ② tr 元素

```
属性:

    cells		本行所有单元格集合
    
    rowIndex	本行索引

方法:

    insertCell()	插入一单元格
    
    deleteCell()	删除一单元格
```

>   th tr 同类型

#### ③ td 或 th

```
属性:

cellIndex	本单元格在此行的索引
```

### img 元素快速创建

```js
new Image(); //相当于document.createElement('img')
```



## 事件

### 事件监听

#### ① 添加监听事件(三种)

**第一种方式：把事件作为 HTML 标签的属性：**

```html
<button onclick="代码"></button>
```

**第二种方式： 把事件作为元素对象的方法：**

```js
element.onclick = function() {
    
}
```

>   后面会覆盖前面

**第三种方式： 使用 addEventListener 方法：**

```js
element.addEventListener('click', function() {
    
});
```

> dddEventListener可以共存

#### ② 解除监听事件(对应)

**如果是第一种方式和第二种方式监听的事件：**

```js
// 重写写一遍事件监听，把前面的覆盖掉; 使用 null 覆盖原来的函数
element.onclick = null;
```

**如果是 addEventListener() 方法监听的事件：**

```js
element.removeEventListener('click', 回调函数名);
```

> **注意：**不能是匿名函数

>   了解:ie8,touchEvent , detouchEvent

![image-20210409100901986](TyporaImg/image-20210409100901986.png)



### 事件流

事件的触发会经历以下三个阶段：

**捕获阶段：** 从 window、document 一层一层到**目标元素** (具体发生了事件动作的元素)

**目标阶段：** 获取目标元素，标志着捕获阶段的结束，冒泡阶段的开始。

**冒泡阶段：** 从目标元素开始，层层向上，一直到 document、window。

> **注意：**事件默认在冒泡阶段触发（回调函数执行）。

> **注意：** addEventListener 方法的第三个参数设置 true，可以设置事件在捕获阶段触发。



### 事件回调函数中 this 的指向

① **函数中 this 指向的规则：** this 指向调用该函数的对象。

② 事件回调函数中的 this 指向监听了该事件的元素对象， 事件的回调函数由监听了事件的元素调用。



## 常用事件总结

### 1 鼠标~

```
click			单击
dblclick		双击
contextmenu		右击

mouseover		鼠标悬停在元素上， 建议用 mouseenter 代替
mouseout		鼠标离开元素，建议用 mouseleave 代替

mouseenter		鼠标悬停在元素上
mouseleave		鼠标离开元素

mousedown		鼠标按键按下
mouseup		    鼠标按键抬起
mousemove		鼠标移动
```

>   事件参数e,
>
>   事件对象
>
>   `e.clientX/Y`鼠标视口位置
>
>   `e.offsetX/Y` 鼠标元素内位置
>
>   不是函数!



### 2 键盘~

```
keydown		(触发可输入和控制键按键,不区分大小写)键盘按键按下(栅栏)
keyup		键盘按键抬起


keypress	(只有可输入按键,不包括方向键啥的,区分大小写)键盘按键按下(专一)

```

#### ?谁可监听?

>① document
>
>② 表单控件
>已取焦点元素
>可输入元素

#### ?如取按键？




> 键盘事件 event 对象属性：
>
> * event.keyCode 按键 ascii 值
>
> * event.which	  按键 ascii 值(同上)
>
> * event.key	  按键字符串



### 3 文档~

```
load

        |---------window.或body.


        |----------加载成功触发,含元素以及外部资源(src,或href等)


DOMContentLoaded	

        |-----------window.或document.(这两只能使用 addEventListener 监听事件)


        |------------形成完整DOM树之后就触发，不理会图像、javascript文件、CSS文件或其他资源是否下载完毕


beforeunload		

		|------(了解)当关闭网页的时候触发
```

>   window.onload事件会等页面全部加载完(包括外链,比较耗时)

### 4 表单~

```
submit		
		form元素监听
		
		当表单提交的时候触发
---------------------------------------------------------

reset		
		form元素监听
		
		当表单重置的时候触发
---------------------------------------------------------

focus	

		当表单控件获取焦点的时候触发
---------------------------------------------------------

blur		

		当表控件单失去焦点的时候触发    (适用验证文本输入框)

---------------------------------------------------------

select		
		输入框或文本域中的内容被选中

---------------------------------------------------------

change		
		
		对于输入框，内容改变且失去焦点才会触发   (适合用于select)
```

### 5 链接加载~

```
load		加载成功触发

error		加载失败触发
```

### 6 窗口~

```
resize		
		window监听 , 视口大小发生改变

-------------------------------------------------

scroll		
		window/滚动条元素监听，页面或元素中内容发生滚动就触发。
```

## 事件 对象

### 1 ~获取 

```

给事件回调函数设置第一个形参，可以获取 event 对象。


----------------------------------------------------
不同类型事件获取 Event 对象类型不同。
-----------------------------------------------------
```



### 2 MouseEvent 对象

鼠标事件对象 MouseEvent 的属性和方法

```
offsetX / offsetY		获取鼠标在目标元素上的坐标位置
clientX / clientY		获取鼠标在视口上的坐标位置
pageX / pageY			获取鼠标在页面上的坐标位置
screenX / screenY       获取鼠标在屏幕上的坐标位置
button					获取按的是哪个鼠标按键， 0：左键； 1:中间键; 2:右键
```

 ### 3 KeyBorardEvent 对象

键盘事件对象 KeyBorardEvent 的属性和方法

```
keyCode		获取按键对应的编码值
which		同 keyCode
key			获取按键对应的字符值
```





### 4 事件对象 共有属性&方法

所有类型事件对象共有属性&方法

```
type				获取事件名

timeStamp			获取触发事件时距离打开页面时的毫秒数

target				获取目标元素

stopPropagation()	阻止事件冒泡

preventDefault()	阻止浏览器默认行为
```



### 5 事件冒泡阻止

在事件的回调函数中执行 `event.stopPropagation()`，就可以阻止冒泡。

### 6  浏览器默认行为

#### ① ?有哪些默认行为?

```
超链接点击跳转
表单的提交和重置
右键弹出系统菜单
等...
```

#### ② 阻止默认行为

在事件的回调函数中调用 `event.preventDefault()` 即可阻止默认行为。

> **注意：** 如果使用 第二种方式监听事件(事件作为元素对象方法) ，在回调函数中 `return false` 同样可以阻止默认行为。
>
> 但不能阻止冒泡 , 不过在JQuery中可以



## 事件委托

事件监听到祖先元素上，判断目标元素，如果目标元素满足条件，就执行相关操作。

事件委托的优势：

1. 对于给大量的元素监听相同的事件，使用事件委托比遍历挨个监听效率更好。
2. 利用事件委托可以让新增的元素也可以响应事件。

>   运用`target`判断是否是目标元素

![image-20210414205441889](TyporaImg/image-20210414205441889.png)

## DOM 对象深入分析

### 1 元素 对象的原型链关系

```
HTMLDivElement类型  ->  HTMLElement类型 -> Element类型 -> EventTarget类型 -> Object 类型 -> Object.prototype
```

### 2 事件 对象的原型链关系

```
MouseEvent类型 -> UIEvent类型 -> Event类型 -> Object类型 -> Object.prototype
```

### 3 HTMLCollection 和 NodeList 的区别

#### ① HTMLCollection 对象

* ```
    * getElementsByTagName()、getElementsByClassName()、document.all、children 等方式方法可以获取到 HTMLCollection 类型的对象
    * HTMLCollection 类型的对象中的成绩必须都是元素节点。
    * 该对象没有 forEach 方法
    --------------------------------------------------------------------------------------------
    * **HTMLCollection 对象是动态的，可以实时更新集合中的元素。**
    
    类似地址类型 , 只有一个
    --------------------------------------------------------------------------------------------
    ```

    

#### ② NodeList

* ```
    * getElementsByName()、querySelectAll()、childNodes 等方式方法可以获取 NodeList 类型的对象
    * NodeList 类型的对象中的元素可以是任意类型的节点（元素、文本节点、注释节点、document 等）
    * 该对象有 forEach 方法
    --------------------------------------------------------------------------------------------
    * **NodeList 对象是静态的对象。**
    
    类似变量 , 有多个 ,.............
    --------------------------------------------------------------------------------------------
    ```




## 垃圾回收机制（GC）

### 1.1 垃圾回收相关概念

#### ① 什么是垃圾

没有被使用（引用）对象———–>**垃圾**

#### ② 什么是垃圾回收

没有被引用的对象被销毁，内存被释放，就是**垃圾回收**。

C、C++ 等编程语言需要手动垃圾回收。

Java、JavaScript、PHP、Python 等变成语言自动垃圾回收。

#### ③ 变量生命周期（何时会被回收）

**全局变量：** 整个脚本执行完毕，全局变量就被销毁。

**局部变量：** 函数调用完毕，局部变量就被销毁。

#### ④ 垃圾没有及时回收的后果

没有被及时回收的垃圾会常驻内存，造成**内存泄漏**。

#### ⑤ 垃圾回收的常见算法

```
- 引用计数
- 标记清除
```

### 1.2 引用计数

#### ① 原理

```
- 1 每个对象都有一个引用标记，记录引用次数
- 2 如果对对象进行引用，引用标记+1
- 3 如果取消了对对象的引用，引用标记-1
- 4 当对象的引用标记次数为 0，就变为垃圾对象，会立即被清除。
```

#### ② 优缺点：

```
- 优点： 垃圾对象比清除地非常及时
- 缺点： 如果两个对象互相引用，会造成两个对象常驻内存，造成内存泄漏
```

![image-20210412143738675](TyporaImg/image-20210412143738675.png)

### 1.3 标记清除

#### ① 原理

```
浏览器会不停地进行垃圾回收的循环，每次循环经历两个阶段:


- 标记阶段:
  	从根对象开始，一层一层向下找，对所有的能找到的对象进行标记，有标记的对象成为可到达对象，没有标记的对象就是不可到达对象，也就是垃圾对象。


- 清除阶段:
      线性变量内存中所有的对象，如果对象没有标记就作为垃圾被清除。
      清除完垃圾之后，去掉所有对象的标记，继续进行下一轮的标记清除。
```

#### ② 优缺点

```
- 优点：不会造成内存泄漏
- 缺点：需要进行深度递归遍历，垃圾回收不如引用计数方式更及时。
```

![image-20210412143908659](TyporaImg/image-20210412143908659.png)





## 执行上下文和执行栈

### 2.1 执行上下文

#### ① 全局执行上下文

```
1. 全局代码正式执行之前，创建全局执行上下文对象，赋值给 window。
2. 对全局的数据进行预处理
   1) 所有使用 var 声明的全局变量进行提升，添加为 window 的属性。
   2) 所有使用 function 关键字声明的函数进行提升，添加为 window 的方法。
   3) 给 this 赋值为 window
3. 开始执行全局代码
```

#### ② 函数内的执行上下文

```
1. 当函数**被调用**的时候，函数体内的代码执行之前，先创建函数的执行上下文对象
2. 对局部的数据进行预处理
    1)给形参赋值，把形参添加为执行上下文对象的属性。
    2)给 arguments 赋值，添加为执行上下文对象的属性。
    3)对函数内使用 var 声明的变量进行提升，添加为执行上下文对象的属性。
    4)对函数内使用 function 关键字声明的函数进行提升，添加为执行上下文对象的方法。
    5)给 this 赋值为调用该函数的对象(this不是执行上下文对象,是new 的对象)
3. 开始执行函数体的代码
```

> **注意：** 函数每调用一次，就创建一个执行上下文对象！

### 2.2 执行栈

**先进后出**

**执行栈**也叫调用栈，用于存储代码执行过程中产生的执行上下文对象。

**栈** 使用经典的数据存储结构，特点是先进后出、后进先出。 数据进入栈成为**压栈**或**进栈**， 数据移除栈（销毁）称为**出栈**。

```
1. 代码执行之前，创建一个执行栈对执行上下文对象进行管理。
2. 全局执行上下文对象创建之后，进入执行栈（进栈）
3. 当调用函数的时候，会创建本次函数调用的执行上下文对象，进入执行栈（进栈）
4. 函数调用结束，本次函数调用的执行上下文对象被销毁（出栈）
5. 最会，栈中只剩全局执行上下文对象，待所有代码执行完毕，出栈。
```

### 2.3  作用域和执行上下文的关系

```
区别：
1. 作用域是静态的，变量的作用域只与所在函数声明的位置有关，无在哪里调用无关。
2. 执行上下文对象是动态的，没调用一次函数，就创建一个执行上下文对象。

联系：
执行上下文对象也属于所在的所用域
全局执行上下文 -> 全局作用域
函数的执行上下文 -> 函数的局部作用域
```

## 闭包

### 3.1 什么是闭包？

```
指有权访问另一个函数作用域中的数据 -------------现象
```

MDN 上面这么说：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。

### 3.2 如何产生闭包

```js
 // 声明函数 A
function A() {
    // 定义局部变量
    var a = 100;
    var b = 200;

    // 定义函数 B
    function B() {
        return a + b;
    }

    // 把函数返回
    return B;
}

// 调用函数 A 并获取返回值
var fn = A();

// 调用函数 f
console.log(fn());
```

```
1. 有函数A，函数A中有自己作用域的数据， 在函数A里面定义函数B
2. 函数B中使用函数A里面的数据
3. 函数B作为函数A的返回值，或者让函数B被其他方式引用（作为事件的回调函数、赋值给全局变量）
```

>   必须满足此条件,否则形成不了闭包.`函数中变量数据从全局找`

```js
var b = 1;

function fn1() {

 console.log(b); // ?

}

b=3;

function fn2() {

 var b = 2;

 fn1();

}
fn2();

A、2
B、undefined
C、1
D、3
【参考答案】: D
【您的答案】: A
```



### 3.3 闭包和作用域

```
1. 函数（函数B）可以反问上层作用域中（函数A）的数据
2. 变量的作用域只与函数声明的位置有关系
```

### 3.4 闭包和垃圾回收

```
1. 闭包导致局部变量除了被自己的执行上下文对象引用，还被函数以外的其他函数所引用
2. 函数调用结束，局部也不会变为垃圾对象
3. 总结： 闭包延长了局部变量的生命周期！
```

### 3.5 闭包的缺点

```
闭包延长了局部变量的声明周期，局部变量常驻内存，有内存泄漏的风险。
```

### 3.6 闭包面试题

```js
/*
   说说它们的输出情况
*/

//代码片段一
var name = "The Window";
var object = {
  name: "My Object",
  getNameFunc: function () {
    return function () {
      return this.name;
    };
  }
};
console.log(object.getNameFunc()());  

//代码片段二
var name2 = "The Window";
var object2 = {
  name2: "My Object",
  getNameFunc: function () {
    var that = this;
    return function () {
      return that.name2;
    };
  }
};
console.log(object2.getNameFunc()()); //? MyObject
```

>   this指向调用她的函数 , 如果没有调用她的函数  , 就指向window

```js
/*
   说说它们的输出情况
   */

function fun(n, o) {
  console.log(o);
  return {
    fun: function (m) {
      return fun(m, n)
    }
  }
}
var a = fun(0);   

a.fun(1);           
a.fun(2);           
a.fun(3);           

var b = fun(0).fun(1).fun(2).fun(3);

var c = fun(0).fun(1);  
c.fun(2);  
c.fun(3);
```







![image-20210412165845979](TyporaImg/image-20210412165845979.png)



![image-20210412183655856](TyporaImg/image-20210412183655856.png)

>   **Var没有作用域，然后前面的会被以后一次循环的声明覆盖，所以会是4** , ;用let就可以



## 对象高级

### 2.1 原型链总结

```js
// 定义构造函数
function Foo() {
    
}
// 实例化 Foo
var f1 = new Foo();
var f2 = new Foo();

// 实例化 Object
var o1 = new Object();
var o2 = new Object();
```

```
f1、f2 的构造函数是 Foo
f1、f2 的原型是 Foo.prototype
Foo.prototype 的构造函数是 Object
Foo.prototype.constructor === Foo

o1、o2 的构造函数是 Object
o1、o2 的原型是 Object.prototype

Foo、Object 的构造函数是 Function
Foo、Object 的原型是 Function.prototype


Function 的构造函数是 Function

Foo.protype === f1.__proto__
Foo.__proto__ === Function.prototype

Function.__proto__ === Function.prototype
Object.__proto__ !== Object.protype


```

```
f1、f2  -->  Foo.prototype  -->  Object.prototype
o1、o2  -->  Object.prototype
Foo  -->  Function.prototype -->  Object.prototype
Object --> Function.prototype --> Object.prototype
Function --> Function.prototype --> Object.prototype


Foo.prototype.constructor === Foo
Object.prototype.constructor === Object
Function.prototype.constructor === Function


Foo.prototype === f1.__proto__
Object.prototype === o1.__proto__
Function.prototype === Function.__proto__
```





### 2.2 面向对象继承

#### ① 面向对象语言的继承规则

```java
class User {
    // 定义实例的属性和方法
}

// 定义子类
class VipUser extends User {
    
}

// 定义子类
class NewUser extends User {
    
}

```

> 1. 一个父类可以有多个子类，一个子类只能有一个父类
> 2. 子类的实例不但拥有定义在子类上的属性好方法，还继承了定义在父类的属性和方法

#### ② JS 中继承关系的特点

```
1. JS 中的对象基于原型继承： 对象可以使用原型上的属性和方法，原型链的都可以使用
2. 如果构造函数 A 实例的原型是构造函数 B 的实例，也可以认为构造函数 A 是构造函数 B 的子类
3. instanceof 对象自己的构造函数和对象原型的构造函数，以及原型链上的对象的构造函数，都可以成立
```

```js
// 自定义构造函数
function User() {

}
User.prototype = [100,200];
// 实例化
var u = new User();

console.log(u instanceof User);  // true
console.log(u instanceof Array); // true
console.log(u instanceof Object); // true
```

#### ③ 实现JS中构造函数和构造函数之间继承

```
1. 子类中，先把父类调用一遍，并修改其 this 指向
2. 设置子类的实例的原型是父类的一个实例
3. 设置子类的实例的constructor属性（非必要）
```

```js
// 定义父类
function Person(name, height) {
    this.name = name;
    this.height = height;
}
Person.prototype.eat = function() {
    
}

// 定义子类
function Man(name, height, aaa) {
    // 调用父类，设置父类中 this 的指向
    Person.call(this, name, height);
    this.aaa = aaa;
}
// 设置 Man 实例的原型是 Person 的一个实例
Man.prototype = new Person();
// 指定 constructor 属性
Man.prototype.constructor = Man;
// 添加方法
Man.prototype.fun = function() {}


// 定义子类
function Girl(name, height, bbb) {
	// 把父类调用一遍
    Person.call(this, name, height);
    this.bbb = bbb;
}    
// 设置原型
Girl.prototype = new Person();
Girl.prototype.constructor = Girl;
// 添加方法
Girl.prototype.fn = function() {}
```

### 2.3 安全的类型检测

```js
function getType(data) {
    var str = Object.prototype.toString.call(data)
    return str.slice(8, str.length - 1)
}
```







## 单线程和事件轮询机制

### 3.1 进程和线程

```
1. 什么是进程？
   进程是CUP进行资源调度和分配的基本单位
  
2. 什么是线程？
   线程是CPU进行运算的最小单位， 进程的运算也要基于线程
   
  
3. 进程和线程的关系
   - 进程中必须有一个主线程
   - 进程中可以同时运行多个线程，这样的程序叫多线程运行
   - 同一个进程的不同线程可以共享数据
   - 不同进程之间无法直接共享数据
```

### 3.2 JS 单线程运行

```
为什么 JS 是单线程运行？
如果多线程运行，可能不同线程同时修改dom，导致浏览器无法渲染冲突； 最终采用了单线程。
```

### 3.3 同步代码和异步代码

```
1. 同步代码
   同步代码也叫同步任务，按照顺序依次执行，上一个任务执行完毕下一个任务才开始执行。
   
2. 异步代码
   异步代码也叫异步任务，满足执行条件且执行线程空闲（同步代码执行完毕），执行异步任务

3. 哪些是异步任务？
   - 定时器的回调函数
   - DOM 事件的回调函数
   - Ajax 的回调函数
   - Promise 的回调函数
   - script标签赋值scr


4. 注意事项：
   - 开启定时器、监听事件本身是同步任务，它们的回调函数才是异步任务。
   - 异步的代码通常都是回调函数，但是回调函数不一定是异步的。
```

### 3.4 事件轮询机制

```
- 执行栈
  负责执行代码，不论是同步任务还是异步任务都要进行执行栈执行
  
- 管理模块
  负责管理异步任务是否满足执行条件，有定时器管理模块、DOM事件管理模块、Ajax管理模块等
  
- 回调队列
  当管理模块发现异步任务满足条件，将回调函数放入回调队列，等待执行。
  队列的特点:先进先出
  
- 事件轮询
  负责监听执行栈什么时候空闲，一旦执行栈空闲，立即将回调队列中的回调函数放入执行栈执行。

```





# JS(pink)

## 方法&调试

### 调试方法

```
浏览器中按 F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点

Watch: 			监视变量变化

F11: 				程序单步执行
```

### 查阅文档

```
如何学习对象中的方法
    1. 查阅该方法功能    
    2. 查看里面参数 意义和类型
    3. 查看返回值   意义和类型
    4. 通过demo进行 测试
```

```
内置对象使用，学会常用成员即可
```

## 变量

### 声明

### 赋值

### 例、弹出用户名

![image-20210304175644565](JavaScript.assets/image-20210304175644565.png)















## 数据类型

### 显示颜色

>   不同数据类型浏览器color不同

Number：蓝

String：黑

Boolean：蓝

Undefined：灰

Null：灰

![image-20210312190737051](JavaScript/image-20210312190737051.png)

### 99、案列

#### 显示年龄

```
// 弹出一个输入框（prompt)，让用户输入年龄（用户输入）
// 把用户输入的值用变量保存起来,把刚才输入的年龄与所要输出的字符串拼接 （程序内部处理）
// 使用alert语句弹出警示框（输出结果）
var age = prompt('请输入您的年龄');
var str = '您今年已经' + age + '岁了';
alert(str);
```



#### 计算年龄

```
// 1. 弹出输入框，输入出生年份，并存储在变量中
var year = prompt('请输入您的出生年份：'); // 用户输入
// 2. 用今年减去刚才输入的年份 
var result = 2019 - year; // 程序内部处理
// 3. 弹出提示框 
alert('您的年龄是:' + result + '岁'); // 输出结果
```



#### 简单加法

```
计算两个数的值， 用户输入第一个值后，继续弹出第二个输入框并输入第二个值，最后通过弹出窗口显示出两
次输入值相加的结果。
```

```
// 1. 先弹出第一个输入框，提示用户输入第一个值
 var num1 = prompt('请输入第一个值：');
// 2. 再弹出第二个框，提示用户输入第二个值
var num2 = prompt('请输入第二个值：');
// 3. 将输入的值转换为数字型后，把这两个值相加，并将结果赋给新的变量 var result = parseFloat(num1) + parseFloat(num2);
// 4. 弹出结果
alert('结果是:' + result);
```

## 运算符

js常用运算符

```
 算数
 递增和递减
 比较
 逻辑
 赋值
```

### 算术~

```
+-* /%
```

#### 浮点数精度

```
浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。
```

```
var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004console.log(0.07 * 100); // 结果不是 7， 而是：7.000000000000001
```

>   所以不要直接判断两个浮点数是否相等 ! 

### 递增递减~

```
++
```

```
--
```

### 比较~

```
比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值结果:			true or false
```

![image-20210305202130714](JavaScript.assets/image-20210305202130714.png)

>   ！= 会转型



### 逻辑~

```
逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。返回值:			boolean
```

![image-20210305202327534](JavaScript.assets/image-20210305202327534.png)

### 短路运算

```
当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;
```

### 赋值~

![image-20210305202521412](JavaScript.assets/image-20210305202521412.png)

### 优先级~

![image-20210305202552915](JavaScript.assets/image-20210305202552915.png)

## 流程控制

### 顺序~

```
先后顺序，依次执行
```

### if

单分支

```
// if (条件表达式) {}
```

多分枝

```
// if (条件表达式1) { } else if (条件表达式2) { } else if (条件表达式3) {  } else { }
```

### 三元表达

```
表达式1 ? 表达式2 : 表达式3;
```

### switch

```
switch( 表达式 ){  	case value1: 	 	break; 	 	case value2: 	 	break; 	 	default: }
```

>    === 才执行（表达式 === value）

### 循环

#### for

```
for(初始化变量; 条件表达式; 操作表达式 ){ 				//循环体}
```

>   初始化执行一次

**for双重**

```
for (外循环的初始; 外循环的条件; 外循环的操作表达式) {       for (内循环的初始; 内循环的条件; 内循环的操作表达式) {              需执行的代码;       }}
```

>   外层循环执行一次，内层循环要执行全部次数

#### while

```
while (条件表达式) { 		// 循环体代码}
```

```
① 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码② 执行循环体代码③ 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束
```

>   for 与 while不同：
>
>   while 可做较为复杂条件判断，比如判断用户名和密码

#### do while

```
do... while 语句其实是 while 语句的一个变体。**     先执行一次代码块     **然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。
```

```
do { 				// 循环体代码 - 条件表达式为 true 时重复执行循环体代码 				} while(条件表达式);
```

>   至少执行一次

#### continue、break



**continue** 

```
立即跳出本次循环，继续下一次循环
```



**break** 

```
立即跳出整个循环（循环结束）
```



### 练习

#### 进入网吧

```
var usrAge = prompt('请输入您的年龄：');if(usrAge >= 18){ 	alert('您的年龄合法，欢迎来天际网吧享受学习的乐趣！');}
```

#### 判断闺年

```
if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) { 	alert("这个年份是闰年"); } else { // 剩下的是平年 	alert("这个年份是平年"); }
```

>   算法：能被4整除且不能整除100的为闰年（如2004年就是闰年，1901年不是闰年）或者能够被400 整除的就是闰年

#### 是否中奖

```
// 算法 如果你叫刘德华 恭喜您中奖了，否则没有中奖 // 获得用户名 var username = prompt("请输入您的姓名：");  if( username == "刘德华") {      alert("恭喜发财"); } else {      alert("谢谢惠顾,欢迎下次再来"); }
```

#### 判断成绩级别

```
var score = prompt('请您输入分数:');if (score >= 90) {	alert('宝贝，你是我的骄傲');} else if (score >= 80) {	alert('宝贝，你已经很出色了');} else if (score >= 70) {	alert('你要继续加油喽');} else if (score >= 60) {	alert('孩子，你很危险');} else {	alert('熊孩子，我不想和你说话，我只想用鞭子和你说话');
```







#### 数字补0

```
用户输入数字，如果数字小于10，则在前面补 0 ，比如01，09 ，如果数字大于10，则不需要补，比如 20。
```

```
var time = prompt('请您输入一个 0 ~ 59 之间的一个数字');	// 三元表达式 表达式 ？ 表达式1 ：表达式2 var result = time < 10 ? '0' + time : time; // 把返回值赋值给一个变量alert(result);
```

#### 查询水果

```
var fruit = prompt('请您输入查询的水果:');switch (fruit) {case '苹果':     alert('苹果的价格是 3.5/斤');     break;case '榴莲':     alert('榴莲的价格是 35/斤');     break;default:	alert('没有此水果');}
```





#### 求学生成绩

```
var num = prompt('请输入班级总的人数:'); // num 班级总的人数var sum = 0; // 总成绩var average = 0; // 平均成绩for (var i = 1; i <= num; i++) {      var score = prompt('请输入第' + i + '个学生的成绩');      sum = sum + parseFloat(score); }average = sum / num;alert('班级总的成绩是：' + sum);alert('班级总的平均成绩是：' + average);
```

#### n行n列星星

```
var row = prompt('请输入您打印几行星星:');var col = prompt('请输入您打印几列星星:');var str = '';for (var i = 1; i <= row; i++) {      for (j = 1; j <= col; j++) {      	str += '☆';      }      str += '\n';} console.log(str);
```

#### 九九乘法表

![image-20210306211417415](JavaScript.assets/image-20210306211417415.png)

```
var str = ''for (var i = 1; i <= 9; i++) { // 外层for控制 行数 9行 for (var j = 1; j <= i; j++) { // j 控制列数 列数和行数是一样的 j <= i  str += j + " × " + i + " = " + i * j + '\t'; } str += '\n';}console.log(str);
```

#### 你爱我吗

```
do { 	var love = prompt('你爱我吗？');} while (love != '我爱你')alert('登录成功');
```







## 数组

### 概念

就是一组数据的集合 存储在单个变量下的优雅方式 

### 创建

#### new

```
        // new 创建        var arr = new Array(); // 创建了一个空的数组
```



#### 字面量

```
        // 字面量创建数组 []        var arr = []; // 创建了一个空的数组        var arr1 = [1, 2, 'pink老师', true];
```

>   越界无数组元素，输出undefined



>   // 数组里数据逗号分隔
>
>   // 获取数组元素  格式 数组名[索引号]（从0开始）

### 长度

```
数组名 . length
```













### 练习

#### ~元素和及平均值

```
        var arr = [2, 6, 1, 7, 4];        var sum = 0;        var average = 0;        for (var i = 0; i < arr.length; i++) {            sum += arr[i]; // 我们加的是数组元素 arr[i] 不是计数器 i        }        average = sum / arr.length;        console.log(sum, average); // 想要输出多个变量，用逗号分隔即可
```

>   输出多变量，逗号分隔

#### ~转换字符串

```
        // 将数组 ['red', 'green', 'blue', 'pink'] 转换为字符串，并且用 | 或其他符号分割        // 1.需要一个新变量用于存放转换完的字符串 str。        // 2.遍历原来的数组，分别把里面数据取出来，加到字符串里面。        // 3.同时在后面多加一个分隔符        var arr = ['red', 'green', 'blue', 'pink'];        var str = '';        var sep = '*';        for (var i = 0; i < arr.length; i++) {            str += arr[i] + sep;        }        console.log(str);
```

>   新变量存放转换字符串

#### 新增~元素

```
        // 1. 新增数组元素 修改length长度         var arr = ['red', 'green', 'blue'];        console.log(arr.length);        arr.length = 5; // 把我们数组的长度修改为了 5  里面应该有5个元素         console.log(arr);        console.log(arr[3]); // undefined        console.log(arr[4]); // undefined        // 2. 新增数组元素 修改索引号 追加数组元素        var arr1 = ['red', 'green', 'blue'];        arr1[3] = 'pink';        console.log(arr1);        arr1[4] = 'hotpink';        console.log(arr1);        arr1[0] = 'yellow'; // 这里是替换原来的数组元素        console.log(arr1);        arr1 = '有点意思';        console.log(arr1); // 不要直接给 数组名赋值 否则里面的数组元素都没有了
```

>   arr.length = 5     					//数组长度可修改

#### 追加~

```
	   var arr = [];        for (var i = 0; i < 100; i++) {            // arr = i; 不要直接给数组名赋值 否则以前的元素都没了            arr[i] = i + 1;        }
```

>   追加直接，不用声明



#### 筛选~

```
        // 将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组。        // 1、声明一个新的数组用于存放新数据newArr。        // 2、遍历原来的旧数组， 找出大于等于 10 的元素。        // 3、依次追加给新数组 newArr。        // 方法1        var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];        var newArr = [];        var j = 0;        for (var i = 0; i < arr.length; i++) {            if (arr[i] >= 10) {                // 新数组索引号应该从0开始 依次递增                newArr[j] = arr[i];                j++;            }        }        console.log(newArr);        // 方法2         var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];        var newArr = [];        // 刚开始 newArr.length 就是 0        for (var i = 0; i < arr.length; i++) {            if (arr[i] >= 10) {                // 新数组索引号应该从0开始 依次递增                newArr[newArr.length] = arr[i];            }        }        console.log(newArr);
```

>   方法二



#### ~去重

```
        // 将数组[2, 0, 6, 1, 77, 0, 52, 0, 25, 7]中的 0 去掉后，形成一个不包含 0 的新数组。        // 1、需要一个新数组用于存放筛选之后的数据。        // 2、遍历原来的数组， 把不是 0 的数据添加到新数组里面(此时要注意采用数组名 + 索引的格式接收数据)。        // 3、新数组里面的个数， 用 length 不断累加。        var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];        var newArr = [];        for (var i = 0; i < arr.length; i++) {            if (arr[i] != 0) {                newArr[newArr.length] = arr[i];            }        }        console.log(newArr);
```

>   newArr[newArr.length] = arr[i];

#### 翻转~

```
        // 将数组 ['red', 'green', 'blue', 'pink', 'purple'] 的内容反过来存放        // 1、声明一个新数组 newArr        // 2、把旧数组索引号第4个取过来（arr.length - 1)，给新数组索引号第0个元素 (newArr.length)        // 3、我们采取 递减的方式  i--        var arr = ['red', 'green', 'blue', 'pink', 'purple', 'hotpink'];        var newArr = [];        for (var i = arr.length - 1; i >= 0; i--) {            newArr[newArr.length] = arr[i]        }        console.log(newArr);
```



#### 交换两变量

```
        // 交换两个变量        var num1 = 'pink';        var num2 = 'yellow';        var temp;        temp = num1;        num1 = num2;        num2 = temp;        console.log(num1, num2);
```

>   复习

#### 冒泡排序

```
        // 冒泡排序        // var arr = [5, 4, 3, 2, 1];        var arr = [4, 1, 2, 3, 5];        for (var i = 0; i <= arr.length - 1; i++) { // 外层循环管趟数             for (var j = 0; j <= arr.length - i - 1; j++) { // 里面的循环管 每一趟的交换次数                // 内部交换2个变量的值 前一个和后面一个数组元素相比较                if (arr[j] < arr[j + 1]) {                    var temp = arr[j];                    arr[j] = arr[j + 1];                    arr[j + 1] = temp;                }            }        }        console.log(arr);
```

>   函数也有























## 函数

概念

```
在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。
```



### 使用

#### 1 声明（2种）

**命名~**

```
// 声明定义方式function fn() {...}// 调用 fn();
```

```
 因为有名，称命名函数 前，后   调用函数可放声明函数  
```







**匿名~**

```
// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...}；// 调用的方式，函数调用必须写到函数体下面fn();
```

```
 因为没名，称匿名函数 fn 里面存储函数  函数表达式方式原理跟声明变量方式是一致的 函数体后面    函数调用必须写到
```





>   function 关键字
>
>   函数名动词，比如 getSum 









#### 2 调用

```
					// 调用函数函数名(); 		// 通过调用函数名来执行函数体代码
```

>   函数可以相互调用



#### 3 封装

```
函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口
```

### 参数



#### 形参、实参



![image-20210306191149927](JavaScript.assets/image-20210306191149927.png)



形参（不用声明变量），实参



#### 形、实参个数不匹

![image-20210306191818367](JavaScript.assets/image-20210306191818367.png)

### 返回值





#### return语句

```
function 函数名（）{ 	... 	return 		需要返回的值  ；      //返回并停止.}
```

>   undefined 返回，无 return

>   返回，停止

>   一个值返回，逗号隔开多值  取后值







### arguments

```
JavaScript中		arguments是当前函数内置对象			存储传递所有实参。
```



**伪数组**

```
arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：	 length 属性具有 索引方式储存数据 不具有数组的 push , pop 等方法
```







### 练习

#### 1~100累加

```
   /*    计算1-100之间值的函数   */function getSum(){       var sumNum = 0;    // 准备一个变量，保存数字和              for (var i = 1; i <= 100; i++) {                    sumNum += i; // 把每个数值 都累加 到变量中                    }       alert(sumNum);}// 调用函数getSum();
```

#### ~求两个数和

```
function getSum(num1, num2) { 	console.log(num1 + num2);}getSum(1, 3); // 4getSum(6, 5); // 11
```

#### ~求任两数最大

```
function getMax(num1, num2) { 		return num1 > num2 ? num1 : num2;}console.log(getMax(1, 2));
```

>   三目运算

#### ~求任数组最大

```
//定义函数function getMaxFromArr(numArray){      var maxNum = 0;            for(var i =0;i < numArray.length;i++){                 if(numArray[i] > maxNum){                      maxNum = numArray[i];                 	 }      }      return maxNum;   }var arrNum = [5,2,99,101,67,77];
```

>   遍历



#### 两数+-×÷

```
var a = parseFloat(prompt('请输入第一个数'));var b = parseFloat(prompt('请输入第二个数'));function count(a, b) {      var arr = [a + b, a - b, a * b, a / b];      return arr;      }var result = count(a, b);console.log(result);
```



#### 任意数最大值

```
function maxValue() {      var max = arguments[0];            for (var i = 0; i < arguments.length; i++) {                 if (max < arguments[i]) {                      	max = arguments[i];           	      	 }      }      return max; console.log(maxValue(2, 4, 5, 9));
```

>   arguments使用



#### 翻转任一数组

```
function reverse(arr) {     var newArr = [];          for (var i = arr.length - 1; i >= 0; i--) {          	newArr[newArr.length] = arr[i];	//newArr.length = 0,然后被赋值     	     }     return newArr;}var arr1 = reverse([1, 3, 4, 6, 9]);console.log(arr1);
```

>   注释

#### 冒泡排序数组

```
function sort(arr) {     for (var i = 0; i < arr.length - 1; i++) {                    for (var j = 0; j < arr.length - i - 1; j++) {                                   if (arr[j] > arr[j + 1]) {                         var temp = arr[j];                         arr[j] = arr[j + 1];                         arr[j + 1] = temp;                    }          	}     }     return arr;}
```

>   健忘



#### 判断闺年

```
闰年：能被4整除并且不能被100整数，或者能被400整除
```

```
function isRun(year) {      	 var flag = false;                 if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {                      	flag = true;           	           }                 	 return flag;}console.log(isRun(2010));console.log(isRun(2012));
```

>   痛年



#### 当年二月天数

```
如果是闰年，则2月份是 29天， 如果是平年，则2月份是 28天
```



## 作用域

### 全局~、局部~



```
JavaScript作用域				就是代码名字（变量）在某个范围内起作用和效果 				目的：					提高程序可靠性、减少命名冲突
```

#### 全局

```
                                全局作用域：         			整个script标签 或者是一个单独的js文件        
```



#### 局部

```
        局部作用域：				（函数作用域）                //函数内部是局部作用域 只在函数内部起效果和作用                function fn() {                    // 局部作用域            var num = 20;                    }
```



### 变量~





| 全局变量                                     | 局部变量                      |
| -------------------------------------------- | ----------------------------- |
| ①函数内部没有声明直接赋值<br>②全局作用域声明 | ①函数形参 <br>②局部作用域声明 |









### 块级~

```
js	es6新增		块级作用域
```



```
        // 块级作用域 {}   if {}  for {}                        // java         // if(xx) {        //     int num = 10;        // }                        // 外面的是不能调用num的        if (3 < 5) {            var num = 10;        }        console.log(num);
```





### ~链



```
// 作用域链 		内部函数访问外部函数变量						采取链式查找方式决定取哪值 									这种结构我们称为作用域链   											就近原则
```



```
        var num = 10;    function fn() { // 外部函数        var num = 20;        function fun() { // 内部函数        	console.log(num);        }        fun();    }    fn();
```



### 预解析

```
js引擎运行js 分为两步：		预解析  			代码执行						(1)预解析 			var、function 	提升到当前作用域的最前面（js里面所有的）		           预解析           		分为 变量预解析（变量提升） 和 函数预解析（函数提升）	                        变量提升                 	就是把所有的变量声明提升到当前的作用域最前面  不提升赋值操作                函数提升                 	就是把所有的函数声明提升到当前作用域的最前面  不调用函数										(2)代码执行  			代码书写顺序执行                        
```



## 对象

### 创建





#### 对象字面量创建

```
        //空对象                var obj = {};                //非空对象                var obj = {                uname: '张三疯',                age: 18,                sex: '男',                sayHi: function() {                    console.log('hi~');                }         }
```



```
属性名 ： 属性值					//里面属性方法采取键值对形式  逗号隔开						  //多个属性方法中间跟匿名函数				  		 //方法冒号后面
```

#### new Object创键

```
	// 先创建空对象	  var obj = new Object(); 		        obj.uname = '张三疯';        obj.age = 18;        obj.sex = '男';        obj.sayHi = function() {                console.log('hi~');        }                            // (1) 添加对象属性、方法	等号  赋值            // (2) 属性、方法 		   分号结束
```



#### 构造创建



```
       // new 构造函数名();       function Star(uname, age, sex) {                    this.name = uname;            this.age = age;            this.sex = sex;            this.sing = function(sang) {                console.log(sang);            }        }        var ldh = new Star('刘德华', 18, '男'); // 调用函数返回的是一个对象
```

```
(规范)构造函数名字首字母大写构造函数不需要return 就可以返回结果调用构造函数必须使用 newnew Star() 调用函数创建一个对象 ldh  {}属性和方法前面必须添加 this
```

>           // 1. new 构造函数可以在内存中创建了一个空的对象 
>           // 2. this 就会指向刚才创建的空对象
>           // 3. 执行构造函数里面的代码 给这个空对象添加属性和方法
>           // 4. 返回这个对象



















### 使用

```
使用对象console.log(	obj.uname	);			//(法一)调用对象属性    对象名.属性名console.log(	obj['age']	);			//(法二)			    对象名['属性名']        obj.sayHi();							//调用对象方法sayHi    对象名.方法名()
```





### 遍历



```
        // 遍历对象         var obj = {                name: 'pink老师',                age: 18,                sex: '男',                fn: function() {}            }            // console.log(obj.name);            // console.log(obj.age);            // console.log(obj.sex);            // for in 遍历我们的对象            // for (变量 in 对象) {        // }        for (var k in obj) {            console.log(k); // k 变量 输出  得到的是 属性名            console.log(obj[k]); // obj[k] 得到是 属性值        }        // 我们使用 for in 里面的变量 我们喜欢写 k  或者  key
```

>           for (var k in obj) {
>
>               属性名 属性值console.log(k); 		// k 			 变量，属性名console.log(obj[k]); 	// obj[k] 		 属性值
>
>           }





## 内置对象



### 介绍

```
JavaScript对象分3：				自定义对象	 (属ECMAScript)												内置对象      (属ECMAScript),JS 语言自带，Math、 Date 、Array、String........                                                        								浏览器对象	  (JS 独有)
```

### Math~

>   Math 对象（静态函数,）

#### 很多方法

```asdf
Math.PI 				// 圆周率Math.floor() 			// 向下取整Math.ceil() 			// 向上取整 , 天花板Math.round() 			// 四舍五入 就近取整 注意 -3.5 结果是 -3 a's'd'fMath.abs() 				// 绝对值Math.max()/Math.min() 	// 求最大和最小值Math.random()				//随机数方法(下) 
```



#### random（）

```
random()		随机返回一个小数					范围[0，1)								
```





### 日期~

#### 概述

>   非静态函数
>
>   实例化后使用



#### 有无参date()

**有参：**

返回参数里时间

```
括号里有时间例如日期格式字符串为‘2019-5-1’，可以写成new Date('2019-5-1') 或 者 new Date('2019/5/1')new Date("2019,3,3")new Date("2019/3/3")new Date("2019-3-3")new Date("2019 3 3")
```

**无参：**

获取当前时间

```
var now = new Date();console.log(now);
```

![image-20210311125916949](JavaScript.assets/image-20210311125916949.png)



#### 格式化

得到我们想要

或时

或分

或秒

**当前**

```
一个日期对象，获取它里面				年月日时分秒
```

![image-20210311130922659](JavaScript.assets/image-20210311130922659.png)

| name          | 当前,当       | code |
| ------------- | ------------- | ---- |
| getFullYear() | 年            |      |
| getMonth()    | 0 - 11 月     |      |
| getDate()     | 日期          |      |
| getDay()      | 0周日 - 6周六 |      |
| getHours()    | 小时          |      |
| getMinutes()  | 分钟          |      |
| getSeconds()  | 秒            |      |



#### 总毫秒形式f

**对象.方法名**

```
valueOf() & getTime()        返回Date()对象 时间戳(指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的														总秒数)        var date = new Date();        date.valueOf();        date.getTime();                简单的写法(最常用写法)(触发对象执行valueOf)                var date1 = +new Date(); // +new Date()  返回时间戳    +自动触发类型转换,变成Number        console.log(date1);        H5新增获得总毫秒数（兼容问题）                console.log(Date.now());
```



>    +new Date()
>
>    触发对象执行valueOf 求值
>
>    ```
>    var now = new Date, time = now.getTime();console.log(time==now.valueOf());//trueconsole.log(time==+now);//true
>    ```







### 数组~

#### 创建~对象

##### 字面量方式

```
        // 1. 利用数组字面量        var arr = [1, 2, 3];        console.log(arr[0]);
```



##### new Array()方式

一参表数长

多参表元素

```
        // 2. 利用new Array()                // var arr1 = new Array();  // 创建了一个空的数组                // var arr1 = new Array(2);  // 这个2 表示 数组的长度为 2  里面有2个空的数组元素                 // var arr1 = new Array(2, 3); // 等价于 [2,3]  这样写表示 里面有2个数组元素 是 2和3
```





#### 检测是不是数组

>   instanceof 			  运算符，可以判断一个对象是否属于某种类型
>
>   Array.isArray()		用于判断一个对象是否为数组，H5新增方法  ie9以上版本支持



```
var arr = [1, 23];var obj = {};console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // falseconsole.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false
```



#### 数组元素添加、删除

**添加：**

```script
        // 添加删除数组元素方法        push() 				在我们数组的末尾 添加一个或者多个数组元素   push  推        var arr = [1, 2, 3];        // arr.push(4, 'pink');        console.log(arr.push(4, 'pink'));        console.log(arr);        // (1) push 是可以给数组追加新的元素        // (2) push() 参数直接写 数组元素就可以了        // (3) push完毕之后，返回的结果是 新数组的长度**********************         // (4) 原数组也会发生变化unshift 				在我们数组的开头 添加一个或者多个数组元素        console.log(arr.unshift('red', 'purple'));        console.log(arr);        // (1) unshift是可以给数组前面追加新的元素        // (2) unshift() 参数直接写 数组元素就可以了        // (3) unshift完毕之后，返回的结果是 新数组的长度 ****************************        // (4) 原数组也会发生变化
```

**删除：**

```
pop() 				它可以删除数组的最后一个元素          console.log(arr.pop());        console.log(arr);        // (1) pop是可以删除数组的最后一个元素 记住一次只能删除一个元素        // (2) pop() 没有参数        // (3) pop完毕之后，返回的结果是 删除的那个元素******************************         // (4) 原数组也会发生变化shift() 				它可以删除数组的第一个元素          console.log(arr.shift());        console.log(arr);        // (1) shift是可以删除数组的第一个元素 记住一次只能删除一个元素        // (2) shift() 没有参数        // (3) shift完毕之后，返回的结果是 删除的那个元素*************************         // (4) 原数组也会发生变化
```

>   返回值：添加 个数，删除 元素
>
>   原数组变化









#### ~排序

![image-20210311142629493](JavaScript/image-20210311142629493.png)

数组对象.方法

```
        // 数组排序        // 1. 翻转数组        var arr = ['pink', 'red', 'blue'];        arr.reverse();        console.log(arr);        // 2. 数组排序（冒泡排序）        var arr1 = [13, 4, 77, 1, 7];        arr1.sort(function(a, b) {            //  return a - b; 升序的顺序排列            return b - a; // 降序的顺序排列        });        console.log(arr1);
```

![image-20210327153717925](TyporaImg/image-20210327153717925.png)

>   下一个 , 上一个



#### ~索引方法

```
indexOf(数组元素)				返回该数组元素的索引号 从前面开始查找lastIndexOf(数组元素)		返回该数组元素的索引号 从后面开始查找
```



```
        		// 返回数组元素索引号方法  indexOf(数组元素)  作用就是返回该数组元素的索引号 从前面开始查找                // 它只返回第一个满足条件的索引号         // 它如果在该数组里面找不到元素，则返回的是 -1          // var arr = ['red', 'green', 'blue', 'pink', 'blue'];        var arr = ['red', 'green', 'pink'];        console.log(arr.indexOf('blue'));                // 返回数组元素索引号方法  lastIndexOf(数组元素)  作用就是返回该数组元素的索引号 从后面开始查找        （应该也是倒数第一个）                var arr = ['red', 'green', 'blue', 'pink', 'blue'];        console.log(arr.lastIndexOf('blue')); // 4
```











#### 数组----->字符串



![image-20210311152402987](JavaScript.assets/image-20210311152402987.png)

```
        // 数组转换为字符串         // 1. toString() 将我们的数组转换为字符串        var arr = [1, 2, 3];        console.log(arr.toString()); // 1,2,3        // 2. join(分隔符)         var arr1 = ['green', 'blue', 'pink'];        console.log(arr1.join()); // green,blue,pink        console.log(arr1.join('-')); // green-blue-pink        console.log(arr1.join('&')); // green&blue&pink
```

#### 其它方法

![image-20210311152604642](JavaScript.assets/image-20210311152604642.png)

```
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
```





### 字符串~

#### 基本包装类型

赋予属性方法（基本数据类型。）

```
js 提供三个特殊引用类型：String、Number、Boolean基本包装类型：					简单数据类型包装成为复杂数据类型
```

**例：**

```css
// 下面代码有什么问题？var str = 'andy';console.log(str.length);
```

>   按道理基本数据类型没有属性和方法，对象有属性和方法，
>
>   上面代码执行因为 js 把
>
>   基本数据类型包装为复杂数据类型，过程：

```css
// 1. 临时变量 生成，把简单类型包装为复杂数据类型var temp = new String('andy');// 2. 赋值 给我们声明的字符变量str = temp;// 3. 销毁 临时变量temp = null;
```



#### 字符串不可变

>   里面值不可变
>
>   改变内容,原因：
>
>   内存中新开辟**新空间**
>
>   
>
>   字符串**所有方法**
>
>   都不会修改字符串本身(字符串不可变)，操作完成会返回一个新的字符串。

```css
var str = 'abc';// 重新赋值，重新内存开辟空间// 效率var str = '';for (var i = 0; i < 100000; i++) { str += i;}console.log(str); // 花费大量时间，不断开辟空间
```



#### 根据字符返回位置

```css
// 字符串对象  根据字符返回位置  str.indexOf('要查找的字符', [起始位置(索引号，包括此索引)])
```



#### 根据位置返回字符

```
charAt(index):									返回 字符at索引处 						charCodeAt(index):									返回 ASCII码at索引处。(判断用户按啥键)str[index]:									返回 字符 索引处(h5，i8支持，等效charAt())						
```



charCodeAt(index)

![image-20210315130304592](JavaScript/image-20210315130304592.png)

####  字符串操作方法

![image-20210311171330949](JavaScript.assets/image-20210311171330949.png)

##### slice（）

```
对象。（[索引，索引)）开始位置截取
```



##### substring（）

```
对象。（[索引，索引)）开始位置截取
```



##### concat（）

```css
        // 字符串操作方法        // 1. concat('字符串1','字符串2'....)        var str = 'andy';        console.log(str.concat('red'));
```

##### substr（）

```css
        // 2. substr('索引', '几个');        var str1 = '改革春风吹满地';        console.log(str1.substr(2, 2)); // 第一个2 是索引号的2 从第几个开始  第二个2 是取几个字符
```



##### replace（）

```css
        // 对象.replace('被替换字符', '替换为字符')  只替换第一个字符        var str = 'andyandy';        console.log(str.replace('a', 'b'));
```

例子：替换全部字符

```css
        // 有一个字符串 'abcoefoxyozzopp'  要求把里面所有的 o 替换为 *        var str1 = 'abcoefoxyozzopp';        while (str1.indexOf('o') !== -1) {            str1 = str1.replace('o', '*');        }        console.log(str1);
```





##### split（）

字符-----》数组



```css
        // 字符转换为数组 split('分隔符')    前面我们学过 join 把数组转换为字符串        var str2 = 'red, pink, blue';        console.log(str2.split(','));        var str3 = 'red&pink&blue';        console.log(str3.split('&'));
```



##### toUpperCase（）

//转换大写





##### toLowerCase（）

//转换小写







### 练习



#### 得两数间随机数



得到一个两数之间随机整数，包括两个数在内

```
function getRandom(min, max) { 		return Math.floor(Math.random() * (max - min + 1)) + min; }
```

>   左闭右开

![image-20210312185054309](JavaScript/image-20210312185054309.png)

#### 当前日期

```
请写出这个格式的日期：2019年8月8日 星期四
```

```
// 格式化日期 年月日 var date = new Date();console.log(date.getFullYear()); // 返回当前日期的年  2019console.log(date.getMonth() + 1); // 月份 返回的月份小1个月   记得月份+1 呦console.log(date.getDate()); // 返回的是 几号console.log(date.getDay()); // 3  周一返回的是 1 周六返回的是 6 但是 周日返回的是 0// 我们写一个 2019年 5月 1日 星期三var year = date.getFullYear();var month = date.getMonth() + 1;var dates = date.getDate();var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];var day = date.getDay();console.log('今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day]);
```

>   星期日妙。



#### 当前时间

```
写一个函数，格式化日期对象，成为 HH:mm:ss 的形式 比如 00:10:45
```

```
    // 格式化日期 时分秒    var date = new Date();    console.log(date.getHours()); // 时    console.log(date.getMinutes()); // 分    console.log(date.getSeconds()); // 秒    // 要求封装一个函数返回当前的时分秒 格式 08:08:08    function getTimer() {    var time = new Date();    var h = time.getHours();    h = h < 10 ? '0' + h : h;    var m = time.getMinutes();    m = m < 10 ? '0' + m : m;    var s = time.getSeconds();    s = s < 10 ? '0' + s : s;    return h + ':' + m + ':' + s;    }    console.log(getTimer());
```



#### 倒计时

![image-20210311132729171](JavaScript.assets/image-20210311132729171.png)





**原理：**

![image-20210311133703966](JavaScript.assets/image-20210311133703966.png)





```
        // 倒计时效果        // 1.核心算法：输入的时间减去现在的时间就是剩余的时间，即倒计时 ，但是不能拿着时分秒相减，比如 05 分减去25分，结果会是负数的。        // 2.用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余时间的毫秒数。        // 3.把剩余时间总的毫秒数转换为天、时、分、秒 （时间戳转换为时分秒）        // 转换公式如下：         //  d = parseInt(总秒数/ 60/60 /24);    //  计算天数        //  h = parseInt(总秒数/ 60/60 %24)   //   计算小时        //  m = parseInt(总秒数 /60 %60 );     //   计算分数        //  s = parseInt(总秒数%60);            //   计算当前秒数                                function countDown(time) {            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数            var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数             var d = parseInt(times / 60 / 60 / 24); // 天            d = d < 10 ? '0' + d : d;            var h = parseInt(times / 60 / 60 % 24); //时            h = h < 10 ? '0' + h : h;            var m = parseInt(times / 60 % 60); // 分            m = m < 10 ? '0' + m : m;            var s = parseInt(times % 60); // 当前的秒            s = s < 10 ? '0' + s : s;            return d + '天' + h + '时' + m + '分' + s + '秒';        }        console.log(countDown('2019-5-1 18:00:00'));        var date = new Date();        console.log(date);
```







#### 筛选数组

>   有一个包含工资的数组[1500, 1200, 2000, 2100, 1800]，要求把数组中工资超过2000的删除，剩余的放到新数组里面

```
var arr = [1500, 1200, 2000, 2100, 1800];var newArr = [];for (var i = 0; i < arr.length; i++) { 		if (arr[i] < 2000) { 		newArr.push(arr[i]); 		 		}}console.log(newArr);
```



#### 数组去重



>   有一个数组[‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]，要求去除数组中重复的元素。

**错误：**

​	去除重复，保留一个。错误保留0个。

```css
        /* 有一个数组[‘c’, ‘a’, ‘z’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’, ‘b’]，要求去除数组中重复的元素。 */        var arr = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b', 'b', 'bb'];        var newArr = [];        for (i = 0; i < arr.length; i++) {            if (arr.indexOf(arr[i]) === arr.lastIndexOf(arr[i])) {                newArr.push(arr[i])            }        }        console.log(newArr);
```

**正确：**

```css
        function unique(arr) {            var newArr = [];            for (var i = 0; i < arr.length; i++) {                if (newArr.indexOf(arr[i]) === -1) {                    newArr.push(arr[i]);                }            }            return newArr;        }
```



#### 出现位置及次数

>   查找字符串"abcoefoxyozzopp"中所有o出现的位置以及次数

```css
    <script>        /* 查找字符串"abcoefoxyozzopp"中所有o出现的位置以及次数 */        var str = "abcoefoxyozzopp";        var locate = str.indexOf('o');        console.log(locate);        var count = 0;        while (locate != -1) {            console.log(locate);            count++;                    /* 注意locate + 1 */                      locate = str.indexOf('o', locate + 1);        }    </script>
```

>    locate = str.indexOf('o', locate + 1);



#### 出现最多字符及次数

```css
<script>        // 有一个对象 来判断是否有该属性 对象['属性名']        var o = {            age: 18        }        if (o['sex']) {            console.log('里面有该属性');        } else {            console.log('没有该属性');        }        //  判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。        // o.a = 1        // o.b = 1        // o.c = 1        // o.o = 4        // 核心算法：利用 charAt(） 遍历这个字符串        // 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1        // 遍历对象，得到最大值和该字符        var str = 'abcoefoxyozzopp';        var o = {};        for (var i = 0; i < str.length; i++) {            var chars = str.charAt(i); // chars 是 字符串的每一个字符            if (o[chars]) { // o[chars] 得到的是属性值                o[chars]++;            } else {                o[chars] = 1;            }        }        console.log(o);        // 2. 遍历对象        var max = 0;        var ch = '';        for (var k in o) {            // k 得到是 属性名            // o[k] 得到的是属性值            if (o[k] > max) {                max = o[k];                ch = k;            }        }        console.log(max);        console.log('最多的字符是' + ch);    </script>
```



#### 7个小问

```css
给定一个字符串，如：“abaasdffggghhjjkkgfddsssss3444343”，问题如下： 1、 字符串的长度2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数7、 遍历字符串，并将遍历出的字符两头添加符号“@”
```



```css
        var str = "abaasdffggghhjjkkgfddsssss3444343f";        // console.log(str.length);        // var char = str.charAt(1);        // var v = str.indexOf("b");        // while (str.indexOf('g') != -1) {        //      str = str.replace('g', '22');        // }        // str = str.substring(1,5);                var obj = new Object();        for(i = 0;i < str.length;i++){            if(obj[str.charAt(i)]){                obj[str.charAt(i)]++;            } else{                obj[str.charAt(i)] = 1;            };        }        var max = 0;        var char = '';        for(k in obj){            if(obj[k] > max){                max = obj[k];                char = k;            }        }                console.log('最多字符：'+char+',次数：'+max);    </script></head><body>    <!-- 给定一个字符串，如：“abaasdffggghhjjkkgfddsssss3444343”，问题如下： 1、 字符串的长度2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数7、 遍历字符串，并将遍历出的字符两头添加符号“@” -->
```



## 简单/复杂 数据类型

**简单**

****

```
值类型	或	基本数据类型存储就是本身值string ，number，boolean，undefined，null
```

**复杂**

```
引用类型存储地址Object、Array、Date等
```

### 堆和栈

简单理解,js没这概念

**堆**

```
存对象,cxy/系统分配回收
```

**栈**

```
存简单数据,系统分配
```



### 内存分配

**简单类型:**

直放栈

>   var v = null;  
>
>   v数据类型是Object;

**复杂类型**

先存栈,再放堆



### 传参

**简单:**

```
先复制,不影响函数外部变量
```

**复杂:**

```
复制栈里堆地址,指向同一对象
```



## DOM

旧

转移同级目录.

### 获取元素

#### getElementById()

```css
				文档页面从上往下加载，		script写到标签下面				返回一个元素对象        var timer = document.getElementById('time');        console.log(timer);        console.log(typeof timer);				console.dir 									打印我们返回的元素对象 更好的查看里面的属性和方法				console.dir(timer);
```

>   返回
>
>   元素对象



#### getElementsByTagName()

```css
				返回  以伪数组形式存储  元素对象集合         var lis = document.getElementsByTagName('li');        console.log(lis);        console.log(lis[0]);				采取遍历依次打印里面元素对象        for (var i = 0; i < lis.length; i++) {            console.log(lis[i]);        }				获取子元素				父元素必须是指定单个元素,不能是  集合        var ol = document.getElementById('ol');        console.log(ol[0].getElementsByTagName('li'));
```

![image-20210315223546385](JavaScript/image-20210315223546385.png)

>   返回
>
>   伪数组集合
>
>   注意:单素多个子素



#### getElementsByClassName()

**(H5)**

```css
    //getElementsByClassName 根据类名获得某些元素集合    var boxs = document.getElementsByClassName('box');    console.log(boxs);
```

>   返回
>
>   对象集合

#### querySelector()

**H5**

```css
        //querySelector 返回指定选择器第一个元素对象        var firstBox = document.querySelector('.box');        console.log(firstBox);
```



#### querySelectorAll()

H5

```css
    //querySelectorAll()返回指定选择器所有元素对象集合    var allBox = document.querySelectorAll('.box');    console.log(allBox);
```


#### document.body

```css
    //获取body 元素        var bodyEle = document.body;
```

#### document.documentElement

```css
    // 获取html 元素    // var htmlEle = document.html;(错误)    var htmlEle = document.documentElement;
```

### 事件

#### 介绍

```css
事件也是属性	<button onclick=“alert('hi~')”></button>	btn.onclick = function() {}
```



#### 鼠标事件图

| 事件类型  | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| click     | 单击鼠标左键时发生，如果右键也按下则不会发生。当用户的焦点在按钮上并按了 Enter 键时，同样会触发这个事件 |
| dblclick  | 双击鼠标左键时发生，如果右键也按下则不会发生                 |
| mousedown | 单击任意一个鼠标按钮时发生                                   |
| mouseout  | 鼠标指针位于某个元素上且将要移出元素的边界时发生             |
| mouseover | 鼠标指针移出某个元素到另一个元素上时发生                     |
| mouseup   | 松开任意一个鼠标按钮时发生                                   |
| mousemove | 鼠标在某个元素上时持续发生                                   |

![image-20210319231725127](TyporaImg/image-20210319231725127.png)

```css
三部分组成  事件源  			对象事件类型  			比如鼠标点击(onclick)事件处理程序			函数赋值			  btn.onclick = function() {            alert('点秋香');        }步骤:		1. 获取事件源		2.绑定事件 注册事件		3.添加事件处理程序 
```

### 操作元素

#### 改变元素内容

```css
    <script>        // 当我们点击了按钮，  div里面的文字会发生变化        // 1. 获取元素         var btn = document.querySelector('button');        var div = document.querySelector('div');        // 2.注册事件        btn.onclick = function() {            // div.innerText = '2019-6-6';            div.innerHTML = getDate();        }        function getDate() {            var date = new Date();            // 我们写一个 2019年 5月 1日 星期三            var year = date.getFullYear();            var month = date.getMonth() + 1;            var dates = date.getDate();            var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];            var day = date.getDay();            return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day];        }        // 我们元素可以不用添加事件        var p = document.querySelector('p');        p.innerHTML = getDate();    </script>
```

>               div.innerText = '2019-6-6';
>               div.innerHTML = getDate();



#### innerHTML / innerText区别

```css
不同:element.innerText									保留文本,至多一空格									删除标签element.innerHTML									保留全部	同:									可读写                    div.innerHTML = '<strong>今天是：</strong> 2019';                  console.log(p.innerText);
```

#### 改元素属性

```css
    		<script>1. 获取元素            var ldh = document.getElementById('ldh');            var zxy = document.getElementById('zxy');            var img = document.querySelector('img');2. 注册事件3.修改属性            zxy.onclick = function() {                img.src = 'images/zxy.jpg';                img.title = '张学友思密达';            }            ldh.onclick = function() {                img.src = 'images/ldh.jpg';                img.title = '刘德华';            }        </script>
```



#### className改元素样式

```css
className更改元素样式             // this.className = 'change';						//保留原来className;												//.change{									新样式;							}            this.className = 'first change';适合:于样式较多或者功能复杂的情况
```



#### style改元素样式

```css
element.style.color驼峰命名适用:只需改少量元素样式
```

>   **注意:**字符串赋值



### 自定义属性

>   程序员自添加属性

```css
// 1. 获取元素属性值// (1) element.属性        console.log(div.id);// (2) element.getAttribute('属性')        console.log(div.getAttribute('id'));        console.log(div.getAttribute('index'));// 2. 设置元素属性值// (1) element.属性= '值'        div.id = 'test';        div.className = 'navs';// (2) element.setAttribute('属性', '值');  主要针对于自定义属性        div.setAttribute('index', 2);        div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是class 不是className// 3 移除属性 removeAttribute(属性)        div.removeAttribute('index');
```

**H5:~**

```css
// h5新增获取自定义属性方法 只能获取		data-		开头// dataset 是一个集合里面存放了所有以data开头 自定义属性        console.log(div.dataset);        console.log(div.dataset.index);					//只需写date-后面元素        console.log(div.dataset['index']);// 当自定义属性里面有多个-链接，我们获取时候采取 驼峰命名法        console.log(div.dataset.listName);        console.log(div.dataset['listName']);
```



### 节点

#### 好处介绍

>   利用层次关系获取元素
>
>   不需每隔元素都要获取



每个节点都拥有包含着关于节点某些信息的属性。这些属性是：

-   nodeName（节点名称）
-   nodeValue（节点值）
-   nodeType（节点类型）

nodeType

nodeType 属性可返回节点的类型。

最重要的节点类型是：

![img](TyporaImg/20160509203610197)



#### 文本~

>   空格,元素包裹内容
>
>   都算文本节点

#### 父~

一个

```css
// 1. parentNode						父节点 (只有一个)// 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null        console.log(erweima.parentNode);
```

#### 子~

**两个**

(不包一子最子)

```css
// DOM 提供的方法（API）获取                    var ul = document.querySelector('ul');        var lis = ul.querySelectorAll('li');            // 1.childNodes 				返回所有  子节点 (所有子节点)				 包含 "元素节点,,文本节点 ....."                    console.log(ul.childNodes);        console.log(ul.childNodes[0].nodeType);        console.log(ul.childNodes[1].nodeType);            // 2.children 					返回所有  子元素节点(子元素节点) 	   不  包含 "元素节点,,文本节点 ....."                    console.log(ul.children);    </script></body></html>
```



#### 一子~最子~

两个

```css
        var ol = document.querySelector('ol');// 1. firstChild 第一个子节点 不管是文本节点还是元素节点(就这两个,建明制衣)        console.log(ol.firstChild);        console.log(ol.lastChild);// 2. firstElementChild 返回第一个子元素节点 ie9才支持        console.log(ol.firstElementChild);        console.log(ol.lastElementChild);// 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素 所以用chilrenconsole.log(ol.children[0]);console.log(ol.children[ol.children.length - 1]);
```

>   最子 , 兄弟 节点方法名很类似
>
>   带有Element才只返回元素节点

#### 兄弟节点

```css
// 1.nextSibling 下一个兄弟节点 包含   "元素"或"文本" 节点等等        console.log(div.nextSibling);        console.log(div.previousSibling);// 2. nextElementSibling 得到下一个兄弟  "元素"  节点        console.log(div.nextElementSibling);        console.log(div.previousElementSibling);
```

>   最子 , 兄弟 节点方法名很类似
>
>   带有Element才只返回元素节点

#### 创建~

```css
// 1. document.write() 							创建元素  缺点:	如果页面文档流加载完毕，再调用这句话会导致页面重绘(声明啥不见)                                    // var btn = document.querySelector('button');                                    // btn.onclick = function() {                                    //     document.write('<div>123</div>');                                    // }// 2. innerHTML 								创建元素优点:	利用数组转换字符串添加方式效率很高                                    var arr = [];                                    for (var i = 0; i <= 100; i++) {                                        arr.push('<a href="#">百度</a>');                                    }                                    inner.innerHTML = arr.join('');缺点:	字符串拼接效率很低                                    var inner = document.querySelector('.inner');                                    // for (var i = 0; i <= 100; i++) {                                    //     inner.innerHTML += '<a href="#">百度</a>'                                    // }// 3. document.createElement() 					创建元素优点:效率innerHTML之间
```



#### 添加~

```css
// 2. 添加   后节点(after)		  appendChild(li)                                  var ul = document.querySelector('ul');                                  ul.appendChild(li);// 3. 添加    前节点(before)		  insertBefore(添加节点,添加节点后一个)																					   var lili = document.createElement('li');       															 ul.insertBefore(lili, ul.children[0]);
```

>   什么节点 , 括号内自己控制
>
>   1.  创建
>   2.  添加



#### 删除~

```css
node.removeChild(child)
```

>   管谁孩子
>
>   都可删除

#### 克隆~





**浅拷贝**                                                   括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容

```css
node.cloneNode()node.cloneNode(false)
```



**深拷贝**													括号为true 深拷贝 复制标签复制里面的内容

```css
node.cloneNode(true)
```





### 笔记













### 99 案例

#### 按钮弹警示框

![image-20210314155019449](JavaScript/image-20210314155019449.png)

```css
var btn = document.getElementById('btn');btn.onclick = function() { alert('你好吗'); };
```





#### 分时显示图片

![image-20210314160022910](JavaScript/image-20210314160022910.png)



```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        img {            width: 300px;        }    </style></head><body>    <img src="images/s.gif" alt="">    <div>上午好</div>    <script>        // 根据系统不同时间来判断，所以需要用到日期内置对象        // 利用多分支语句来设置不同的图片        // 需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性        // 需要一个div元素，显示不同问候语，修改元素内容即可        // 1.获取元素        var img = document.querySelector('img');        var div = document.querySelector('div');        // 2. 得到当前的小时数        var date = new Date();        var h = date.getHours();        // 3. 判断小时数改变图片和文字信息        if (h < 12) {            img.src = 'images/s.gif';            div.innerHTML = '亲，上午好，好好写代码';        } else if (h < 18) {            img.src = 'images/x.gif';            div.innerHTML = '亲，下午好，好好写代码';        } else {            img.src = 'images/w.gif';            div.innerHTML = '亲，晚上好，好好写代码';        }    </script></body></html>
```

>    var h = date.getHours();



#### 仿京东显示密码

![image-20210314160353422](JavaScript/image-20210314160353422.png)

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        .box {            position: relative;            width: 400px;            border-bottom: 1px solid #ccc;            margin: 100px auto;        }                .box input {            width: 370px;            height: 30px;            border: 0;            outline: none;        }                .box img {            position: absolute;            top: 2px;            right: 2px;            width: 24px;        }    </style></head><body>    <div class="box">        <label for="">            <img src="images/close.png" alt="" id="eye">        </label>        <input type="password" name="" id="pwd">    </div>    <script>        // 1. 获取元素        var eye = document.getElementById('eye');        var pwd = document.getElementById('pwd');        // 2. 注册事件 处理程序        var flag = 0;        eye.onclick = function() {            // 点击一次之后， flag 一定要变化            if (flag == 0) {                pwd.type = 'text';                eye.src = 'images/open.png';                flag = 1; // 赋值操作            } else {                pwd.type = 'password';                eye.src = 'images/close.png';                flag = 0;            }        }    </script></body></html>
```

>   var flag = 0;
>
>   表示闭眼



#### 淘宝点击关闭二维码

![image-20210314160851658](JavaScript/image-20210314160851658.png)

```css
var btn = document.querySelector('.close-btn');var box = document.querySelector('.box');// 2.注册事件 程序处理btn.onclick = function() {box.style.display = 'none';
```



#### 循环精灵图背景

![image-20210314161015254](JavaScript/image-20210314161015254.png)



```css
var lis = document.querySelectorAll('li');for (var i = 0; i < lis.length; i++) {          // 让索引号 乘以 44 就是每个li 的背景y坐标 index就是我们的y坐标          var index = i * 44;          lis[i].style.backgroundPosition = '0 -' + index + 'px';  }
```





#### 点击文本框文字隐藏

![image-20210314161131442](JavaScript/image-20210314161131442.png)



```css
    <input type="text" value="手机">    <script>        // 1.获取元素        var text = document.querySelector('input');        // 2.注册事件 获得焦点事件 onfocus         text.onfocus = function() {                // console.log('得到了焦点');                if (this.value === '手机') {                    this.value = '';                }                // 获得焦点需要把文本框里面的文字颜色变黑                this.style.color = '#333';            }            // 3. 注册事件 失去焦点事件 onblur        text.onblur = function() {            // console.log('失去了焦点');            if (this.value === '') {                this.value = '手机';            }            // 失去焦点需要把文本框里面的文字颜色变浅色            this.style.color = '#999';        }    </script>
```

>   this指注册事件  元素



#### 密码格式错误提示



![image-20210314161731504](JavaScript/image-20210314161731504.png)

```css
    <div class="register">        <input type="password" class="ipt">        <p class="message">请输入6~16位密码</p>    </div>    <script>        // 首先判断的事件是表单失去焦点 onblur        // 如果输入正确则提示正确的信息颜色为绿色小图标变化        // 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化        // 因为里面变化样式较多，我们采取className修改样式        // 1.获取元素        var ipt = document.querySelector('.ipt');        var message = document.querySelector('.message');        //2. 注册事件 失去焦点        ipt.onblur = function() {            // 根据表单里面值的长度 ipt.value.length            if (this.value.length < 6 || this.value.length > 16) {                // console.log('错误');                message.className = 'message wrong';                message.innerHTML = '您输入的位数不对要求6~16位';            } else {                message.className = 'message right';                message.innerHTML = '您输入的正确';            }        }    </script>
```



**案例分析**

>   ① 首先判断的事件是表单失去焦点 onblur
>
>   ② 如果输入正确则提示正确的信息颜色为绿色小图标变化
>
>   ③ 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化
>
>   **④ 因为里面变化样式较多，我们采取className修改样式???**



#### 开关灯

```html
    <button id="btn">开关灯</button>    <script>        var btn = document.getElementById('btn');        var flag = 0;        btn.onclick = function() {            if (flag == 0) {                document.body.style.backgroundColor = 'black';                flag = 1;            } else {                document.body.style.backgroundColor = '#fff';                flag = 0;            }        }    </script>
```



#### 歼灭思想(算法)

>   歼灭所有(包己),,重设自己

```css
<body>    <button>按钮1</button>    <button>按钮2</button>    <button>按钮3</button>    <button>按钮4</button>    <button>按钮5</button>    <script>      // 1. 获取所有按钮元素        var btns = document.getElementsByTagName('button');      // btns得到的是伪数组  里面的每一个元素 btns[i]        for (var i = 0; i < btns.length; i++) {            btns[i].onclick = function() {                    // (1) 我们先把所有的按钮背景颜色去掉  干掉所有人                for (var i = 0; i < btns.length; i++) {                                      btns[i].style.backgroundColor = '';                }                    // (2) 然后才让当前的元素背景颜色为pink 留下我自己                              this.style.backgroundColor = 'pink';                          }        }      //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想    </script></body>
```









#### 百度换肤

**分析:**

```css
① 这个案例练习的是给一组元素注册事件② 给4个小图片利用循环注册点击事件③ 当我们点击了这个图片，让我们页面背景改为当前的图片④ 核心算法： 把当前图片的src 路径取过来，给 body 做为背景即可
```

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        * {            margin: 0;            padding: 0;        }                body {            background: url(images/1.jpg) no-repeat center top;        }                li {            list-style: none;        }                .baidu {            overflow: hidden;            margin: 100px auto;            background-color: #fff;            width: 410px;            padding-top: 3px;        }                .baidu li {            float: left;            margin: 0 1px;            cursor: pointer;        }                .baidu img {            width: 100px;        }    </style></head><body>    <ul class="baidu">        <li><img src="images/1.jpg"></li>        <li><img src="images/2.jpg"></li>        <li><img src="images/3.jpg"></li>        <li><img src="images/4.jpg"></li>    </ul>    <script>        // 1. 获取元素         var imgs = document.querySelector('.baidu').querySelectorAll('img');        // console.log(imgs);        // 2. 循环注册事件         for (var i = 0; i < imgs.length; i++) {            imgs[i].onclick = function() {                // this.src 就是我们点击图片的路径   images/2.jpg                // console.log(this.src);                // 把这个路径 this.src 给body 就可以了                document.body.style.backgroundImage = 'url(' + this.src + ')';            }        }    </script></body></html>
```





#### 表格隔行变色

![image-20210314175328702](JavaScript/image-20210314175328702.png)

**分析:**

```html
① 用到新的鼠标事件 鼠标经过 onmouseover 鼠标离开 onmouseout② 核心思路：鼠标经过 tr 行，当前的行变背景颜色， 鼠标离开去掉当前的背景颜色③ 注意： 第一行（thead里面的行）不需要变换颜色，因此我们获取的是 tbody 里面的行
```

```css
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        table {            width: 800px;            margin: 100px auto;            text-align: center;            border-collapse: collapse;            font-size: 14px;        }                thead tr {            height: 30px;            background-color: skyblue;        }                tbody tr {            height: 30px;        }                tbody td {            border-bottom: 1px solid #d7d7d7;            font-size: 12px;            color: blue;        }                .bg {            background-color: pink;        }    </style></head><body>    <table>        <thead>            <tr>                <th>代码</th>                <th>名称</th>                <th>最新公布净值</th>                <th>累计净值</th>                <th>前单位净值</th>                <th>净值增长率</th>            </tr>        </thead>        <tbody>            <tr>                <td>003526</td>                <td>农银金穗3个月定期开放债券</td>                <td>1.075</td>                <td>1.079</td>                <td>1.074</td>                <td>+0.047%</td>            </tr>            <tr>                <td>003526</td>                <td>农银金穗3个月定期开放债券</td>                <td>1.075</td>                <td>1.079</td>                <td>1.074</td>                <td>+0.047%</td>            </tr>            <tr>                <td>003526</td>                <td>农银金穗3个月定期开放债券</td>                <td>1.075</td>                <td>1.079</td>                <td>1.074</td>                <td>+0.047%</td>            </tr>            <tr>                <td>003526</td>                <td>农银金穗3个月定期开放债券</td>                <td>1.075</td>                <td>1.079</td>                <td>1.074</td>                <td>+0.047%</td>            </tr>            <tr>                <td>003526</td>                <td>农银金穗3个月定期开放债券</td>                <td>1.075</td>                <td>1.079</td>                <td>1.074</td>                <td>+0.047%</td>            </tr>            <tr>                <td>003526</td>                <td>农银金穗3个月定期开放债券</td>                <td>1.075</td>                <td>1.079</td>                <td>1.074</td>                <td>+0.047%</td>            </tr>        </tbody>    </table>    <script>        // 1.获取元素 获取的是 tbody 里面所有的行        var trs = document.querySelector('tbody').querySelectorAll('tr');        // 2. 利用循环绑定注册事件        for (var i = 0; i < trs.length; i++) {            // 3. 鼠标经过事件 onmouseover            trs[i].onmouseover = function() {                    // console.log(11);                    this.className = 'bg';                }                // 4. 鼠标离开事件 onmouseout            trs[i].onmouseout = function() {                this.className = '';            }        }    </script></body></html>
```







#### 复选反选

**需求:**

```html
业务需求：1. 点击上面全选复选框，下面所有的复选框都选中（全选）2. 再次点击全选复选框，下面所有的复选框都不中选（取消全选）3. 如果下面复选框全部选中，上面全选按钮就自动选中4. 如果下面复选框有一个没有选中，上面全选按钮就不选中5. 所有复选框一开始默认都没选中状态
```

![image-20210314175634289](JavaScript/image-20210314175634289.png)

**分析:**

```
① 全选和取消全选做法： 让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可② 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。③ 可以设置一个变量，来控制全选是否选中
```

```css
<!DOCTYPE html><html><head lang="en">    <meta charset="UTF-8">    <title></title>    <style>        * {            padding: 0;            margin: 0;        }                .wrap {            width: 300px;            margin: 100px auto 0;        }                table {            border-collapse: collapse;            border-spacing: 0;            border: 1px solid #c0c0c0;            width: 300px;        }                th,        td {            border: 1px solid #d0d0d0;            color: #404060;            padding: 10px;        }                th {            background-color: #09c;            font: bold 16px "微软雅黑";            color: #fff;        }                td {            font: 14px "微软雅黑";        }                tbody tr {            background-color: #f0f0f0;        }                tbody tr:hover {            cursor: pointer;            background-color: #fafafa;        }    </style></head><body>    <div class="wrap">        <table>            <thead>                <tr>                    <th>                        <input type="checkbox" id="j_cbAll" />                    </th>                    <th>商品</th>                    <th>价钱</th>                </tr>            </thead>            <tbody id="j_tb">                <tr>                    <td>                        <input type="checkbox" />                    </td>                    <td>iPhone8</td>                    <td>8000</td>                </tr>                <tr>                    <td>                        <input type="checkbox" />                    </td>                    <td>iPad Pro</td>                    <td>5000</td>                </tr>                <tr>                    <td>                        <input type="checkbox" />                    </td>                    <td>iPad Air</td>                    <td>2000</td>                </tr>                <tr>                    <td>                        <input type="checkbox" />                    </td>                    <td>Apple Watch</td>                    <td>2000</td>                </tr>            </tbody>        </table>    </div>    <script>        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可        // 获取元素        var j_cbAll = document.getElementById('j_cbAll'); // 全选按钮        var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); // 下面所有的复选框        // 注册事件        j_cbAll.onclick = function() {                // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中                console.log(this.checked);                for (var i = 0; i < j_tbs.length; i++) {                    j_tbs[i].checked = this.checked;                }            }            // 2. 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。        for (var i = 0; i < j_tbs.length; i++) {            j_tbs[i].onclick = function() {                // flag 控制全选按钮是否选中                var flag = true;                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中                for (var i = 0; i < j_tbs.length; i++) {                    if (!j_tbs[i].checked) {                        flag = false;                        break; // 退出for循环 这样可以提高执行效率 因为只要有一个没有选中，剩下的就无需循环判断了                    }                }                j_cbAll.checked = flag;            }        }    </script></body></html>
```





#### tab栏切换

![image-20210314180648110](JavaScript/image-20210314180648110.png)

**分析:**

```css
① Tab栏切换有2个大的模块② 上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类名的方式③ 下面的模块内容，会跟随上面的选项卡变化。所以下面模块变化写到点击事件里面。④ 规律：下面的模块显示内容和上面的选项卡一一对应，相匹配。⑤ 核心思路： 给上面的tab_list 里面的所有小li 添加自定义属性，属性值从0开始编号。⑥ 当我们点击tab_list 里面的某个小li，让tab_con 里面对应序号的 内容显示，其余隐藏（排他思想）
```

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        * {            margin: 0;            padding: 0;        }                li {            list-style-type: none;        }                .tab {            width: 978px;            margin: 100px auto;        }                .tab_list {            height: 39px;            border: 1px solid #ccc;            background-color: #f1f1f1;        }                .tab_list li {            float: left;            height: 39px;            line-height: 39px;            padding: 0 20px;            text-align: center;            cursor: pointer;        }                .tab_list .current {            background-color: #c81623;            color: #fff;        }                .item_info {            padding: 20px 0 0 20px;        }                .item {            display: none;        }    </style></head><body>    <div class="tab">        <div class="tab_list">            <ul>                <li class="current">商品介绍</li>                <li>规格与包装</li>                <li>售后保障</li>                <li>商品评价（50000）</li>                <li>手机社区</li>            </ul>        </div>        <div class="tab_con">            <div class="item" style="display: block;">                商品介绍模块内容            </div>            <div class="item">                规格与包装模块内容            </div>            <div class="item">                售后保障模块内容            </div>            <div class="item">                商品评价（50000）模块内容            </div>            <div class="item">                手机社区模块内容            </div>        </div>    </div>    <script>        // 获取元素        var tab_list = document.querySelector('.tab_list');        var lis = tab_list.querySelectorAll('li');        var items = document.querySelectorAll('.item');        // for循环绑定点击事件        for (var i = 0; i < lis.length; i++) {            // 开始给5个小li 设置索引号             lis[i].setAttribute('index', i);            lis[i].onclick = function() {                // 1. 上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类名的方式                // 干掉所有人 其余的li清除 class 这个类                for (var i = 0; i < lis.length; i++) {                    lis[i].className = '';                }                // 留下我自己                 this.className = 'current';                // 2. 下面的显示内容模块                var index = this.getAttribute('index');                console.log(index);                // 干掉所有人 让其余的item 这些div 隐藏                for (var i = 0; i < items.length; i++) {                    items[i].style.display = 'none';                }                // 留下我自己 让对应的item 显示出来                items[index].style.display = 'block';            }        }    </script></body></html>
```





#### 下拉菜单

![image-20210314191456705](JavaScript/image-20210314191456705.png)

**分析:**

```
① 导航栏里面的li 都要有鼠标经过效果，所以需要循环注册鼠标事件② 核心原理： 当鼠标经过li 里面的 第二个孩子 ul 显示， 当鼠标离开，则ul 隐藏
```

```css
var nav = document.querySelector('.nav');var lis = nav.children; 									// 得到4个小lifor (var i = 0; i < lis.length; i++) {          lis[i].onmouseover = function() {                  				this.children[1].style.display = 'block';                  }          lis[i].onmouseout = function() {                  				this.children[1].style.display = 'none';                  }}
```



#### 留言案例

**分析**

```
① 核心思路： 点击按钮之后，就动态创建一个li，添加到ul 里面。② 创建li 的同时，把文本域里面的值通过li.innerHTML 赋值给 li③ 如果想要新的留言后面显示就用 appendChild 如果想要前面显示就用insertBefore
```

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        ul{            list-style: none;        }        .textarea{            width: 300px;            height: 100px;            outline: none;            /* resize: none; */            border: 1px solid #ccc;        }        .btn{            width: 40px;            height: 30px;          }        li{            width: 300px;            height: 100px;        }    </style></head><body>    <input type="text" class="textarea" name="" id="">    <button class="btn"></button>    <ul>    </ul>    <script>        var textarea = document.querySelector(".textarea");                var btn = document.querySelector(".btn");                    btn.onclick = function(){                var text = textarea.value;                var li = document.createElement("li");                li.innerHTML = text;                var ul = document.querySelector("ul");                ul.insertBefore(li,ul[0]);            }          </script></body></html>
```

>   document.createElement("li");
>
>   insertBefore(li,ul[0]);



****

```css
                    as[i].onclick = function() {                        // node.removeChild(child); 删除的是 li 当前a所在的li  this.parentNode;                        ul.removeChild(this.parentNode);                    }
```

>   removeChild
>
>   真正删除





#### 删除留言



**分析**

```
① 当我们把文本域里面的值赋值给li 的时候，多添加一个删除的链接② 需要把所有的链接获取过来，当我们点击当前的链接的时候，删除当前链接所在的li③ 阻止链接跳转需要添加 javascript:void(0); 或者 javascript:;
```

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        ul {            list-style: none;        }        .textarea {            width: 230px;            height: 50px;            outline: none;            padding: 0;            /* resize: none; */            border: 1px solid #ccc;        }        .btn {            width: 50px;            height: 30px;        }        li {            width: 300px;            height: 30px;        }    </style></head><body>    <input type="text" class="textarea" name="" id="">    <button class="btn">发布</button>    <ul>    </ul>    <script>        var textarea = document.querySelector(".textarea");        var btn = document.querySelector(".btn");        var btn2 = document.querySelector(".btn2");        //添加        btn.onclick = function () {            var text = textarea.value;            if (text != null) {                var li = document.createElement("li");                li.innerHTML = text + "<a href='#'>删除</a>";                var ul = document.querySelector("ul");                ul.insertBefore(li, ul[0]);                var as = document.querySelectorAll("a");                for (i = 0; i < as.length; i++) {                    as[i].onclick = function () {                        this.parentNode.style.display = "none";                    }                }            } else {                return false;            }        }    </script></body></html>
```

>   li.innerHTML = text + "<a href='#'>删除</a>";
>
>   parentNode







#### 动态生成表格

![image-20210314193246554](JavaScript/image-20210314193246554.png)



**分析**

```
① 因为里面的学生数据都是动态的，我们需要js 动态生成。 这里我们模拟数据，自己定义好数据。 数据我们采取对象形式存储。② 所有的数据都是放到tbody里面的行里面。③ 因为行很多，我们需要循环创建多个行（对应多少人）④ 每个行里面又有很多单元格（对应里面的数据），我们还继续使用循环创建多个单元格，并且把数据存入里面（双重for循环）⑤ 最后一列单元格是删除，需要单独创建单元格。⑥ 最后添加删除操作，单击删除，可以删除当前行
```

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        table {            /* border:1px solid #ccc; */            border-collapse: collapse;            table-layout: fixed;            margin: 50px auto;            width: 600px;        }        td {            border: 1px solid #000;        }    </style></head><body>    <table>        <thead>            <tr>                <td>姓名</td>                <td>学科</td>                <td>分数</td>                <td></td>            </tr>        </thead>        <tbody>                    </tbody>    </table>    <script>        /* 数据 */        var objs = [            {                name: "xiaolu",                major: "java",                score: 99            },            {                name: "zl",                major: "c",                score:90            },            {                name: "mg23423415",                major: "vue",                score: 100            },            {                name: "zl",                major: "c",                score:90            },            {                name: "mg",                major: "vue",                score: 100            }        ];         var tbody = document.querySelector("tbody");                for(i = 0;i < objs.length;i++){            // console.log(objs[i]);            var tr = document.createElement("tr");            tbody.appendChild(tr);            for(k in objs[i]){                var td = document.createElement("td");                tr.appendChild(td);                td.innerHTML = objs[i][k];                // console.log(objs[i][k]);            }            var db = document.createElement("td");            tr.appendChild(db);            db.innerHTML = "<a href='#'>删除</a>";            // tr.appendChild()            /* b.onclick = function(){                // tbody.removeChild(db.parentNode);                // 删除标签 错误                // tbody.removeChild(tr);                // 删除节点                // tbody.removeChild(this.parentNode);            } */        }        var as = document.querySelectorAll("a");        for(k in as){            // console.log(k);            as[k].onclick = function(){                 tbody.removeChild(this.parentNode.parentNode) ;            }        }    </script></body></html>
```

>   创建
>
>   删除 节点
>
>   注册事件

问题:获取全部a标签,forin遍历多出其它元素

![image-20210318104445647](TyporaImg/image-20210318104445647.png)

![image-20210318104602323](TyporaImg/image-20210318104602323.png)



#### 添加子节点疑难

![image-20210318130235967](TyporaImg/image-20210318130235967.png)



## 高级事件

### 注册~

#### btn.onclick

诸如此类

```css
特点:	唯一性	只能设一个函数,后面覆盖前面
```



#### addEventListener()

```css
特点:	addEventListener()  是方法	同一个元素同一个事件可以注册多个监听器 , 注册顺序依次执行缺点:	attachEvent() IE9 	之前的 IE 不支持此方法，可使用~ 代替方式:	 eventTarget.addEventListener(type, listener[, useCapture])                         type：,, click 、mouseover 等等 ，没 on                         listener：事件处理函数，事件发生时，会调用该监听函数                         useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习	
```

>   非匿名处理函数不写小括号



#### **attachEvent**()

```css
 eventTarget.attachEvent(eventNameWithOn, callback)		 eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on		 callback： 事件处理函数，当目标触发事件时回调函数被调用
```

>   **注意：**IE8 及早期版本支持



#### 兼容方案

```css
 function addEventListener(element, eventName, fn) {         // 判断当前浏览器是否支持 addEventListener 方法         if (element.addEventListener) {                element.addEventListener(eventName, fn); // 第三个参数 默认是false         } else if (ele	ment.attachEvent) {                element.attachEvent('on' + eventName, fn);         } else {                  // 相当于 element.onclick = fn;         element['on' + eventName] = fn; }
```

>   原则： 照顾大多数浏览器，处理特殊浏览器



### 删除~

#### onclick = null

 **传统注册方式**

```
eventTarget.onclick = null;
```



```css
!divs[0].onclick = function() {                    alert(11);                    // 1. 传统方式删除事件                    divs[0].onclick = null;}
```

#### removeEventListener

**方法监听注册方式**

```
① eventTarget.removeEventListener(type, listener[, useCapture]);
```



```css
        divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号        function fn() {                alert(22);                divs[1].removeEventListener('click', fn);        }
```

>   非匿名处理函数不写小括号

#### detachEvent

**方法监听注册方式**

```
② eventTarget.detachEvent(eventNameWithOn, callback);
```



```css
        divs[2].attachEvent('onclick', fn1);        function fn1() {            alert(33);            divs[2].detachEvent('onclick', fn1);        }
```

>   // 里面的fn 不需要调用加小括号

#### 兼容方案

```
 function removeEventListener(element, eventName, fn) {          // 判断当前浏览器是否支持 removeEventListener 方法                  if (element.removeEventListener) {                  		element.removeEventListener(eventName, fn); // 第三个参数 默认是false         		         } else if (element.detachEvent) {                  		element.detachEvent('on' + eventName, fn);         		         } else {                  element['on' + eventName] = null; }
```

### DOM事件流

```
事件流描述的是从页面中接收事件的顺序。事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。比如我们给一个div 注册了点击事件：
```

```
DOM 事件流分为3个阶段：1. 捕获阶段2. 当前目标阶段3. 冒泡阶段
```

![image-20210318133037555](TyporaImg/image-20210318133037555.png)

#### 注意



```
addEventListener(type, listener[, useCapture])								第三个参数如果是 true，表示在事件捕                获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理                程序				捕获 / 冒泡	 只能二选一。
```

#### 限制

```
只有冒泡阶段:onclick / attachEvent 只有捕获阶段:onblur、onfocus、onmouseenter、onmouseleave  
```

### 事件对象

#### 介绍

```
eventTarget.onclick = function(event) {}  eventTarget.addEventListener('click', function(event) {}）   // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
```





#### 使用方法

```
 eventTarget.onclick = function(event) { 		// 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  }  eventTarget.addEventListener('click', function(event) { 		// 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt  }）
```

>   event 形参 , 不需要赋值

#### 兼容方案

>   IE6~8 中，浏览器不会给方法传递参数 , 如果需要的话，需要到 window.event 中获取查找。



```
解决:e = e || window.event;                        div.onclick = function(e) {                                // console.log(e);                                // console.log(window.event);                                // e = e || window.event;                                console.log(e);                        }
```

#### 属性方法



| 事件对象属性方法   | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| e.target           | 返回触发事件的对象         标准                              |
| e.srcElement       | 返回触发事件的对象          非标准    ie6~8使用              |
| e.type             | 返回事件类型                    例如click   mousevoer  不带on |
| e.cancelBubble     | 该属性阻止冒泡               非标准   ie6~8使用              |
| e.returnValue      | 该属性 阻止默认事件 (默认行为)    非标准 ie6~8使用  比如不让链接跳转 |
| e.preventDefault() | 该方法  阻止默认事件 (默认行为)    标准  比如不让链接跳转    |
| e.stopPropagation  | 阻止冒泡    标准                                             |

>   ##### 了解 跟 this 有个非常相似的属性 currentTarget



#### this / target 区别

##### e.target

```
 是事件触发的元素。
```

##### this

```
是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）
```

#### 阻止事件冒泡



事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握



##### e.stopPropagation() 

```
标准写法：利用事件对象里面的 stopPropagation()方法
```



#####  e.cancelBubble = true;

```
非标准写法：IE 6-8 利用事件对象 cancelBubble 属性
```

###### 兼容方案

```
 if(e && e.stopPropagation){ 		e.stopPropagation(); }else{		window.event.cancelBubble = true; }
```

#### 阻止对像默认行为

```
e.preventDefault();
```



```
// 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交			a.addEventListener('click', function(e) {                e.preventDefault(); //  dom 标准写法            })            // 3. 传统的注册方式            a.onclick = function(e) {                // 普通浏览器 e.preventDefault();  方法                // e.preventDefault();                // 低版本浏览器 ie678  returnValue  属性                // e.returnValue;                // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只					限于传统的注册方式                return false;                alert(11);            }
```



#### 事件蔚托

```
<body>    <ul>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>        <li>知否知否，点我应有弹框在手！</li>    </ul>    <script>        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) {            // alert('知否知否，点我应有弹框在手！');            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';        })    </script></body>
```

#### 禁用右键菜单复制

```
<body>    我是一段不愿意分享的文字    <script>        // 1. contextmenu 我们可以禁用右键菜单        document.addEventListener('contextmenu', function(e) {                e.preventDefault();            })            // 2. 禁止选中文字 selectstart        document.addEventListener('selectstart', function(e) {            e.preventDefault();        })    </script></body>
```



#### pageX/pageY

#### clientX/clientY

#### screenX/screenY

鼠标坐标

```
    <script>        // 鼠标事件对象 MouseEvent        document.addEventListener('click', function(e) {            // 1. client 鼠标在可视区的x和y坐标            console.log(e.clientX);            console.log(e.clientY);            console.log('---------------------');            // 2. page 鼠标在页面文档的x和y坐标            console.log(e.pageX);            console.log(e.pageY);            console.log('---------------------');            // 3. screen 鼠标在电脑屏幕的x和y坐标            console.log(e.screenX);            console.log(e.screenY);        })    </script>
```

![image-20210319231816989](TyporaImg/image-20210319231816989.png)

#### 键盘事件

常用

```
    <script>        // 常用的键盘事件        //1. keyup 按键弹起的时候触发         // document.onkeyup = function() {        //         console.log('我弹起了');        //     }        document.addEventListener('keyup', function() {            console.log('我弹起了');        })        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keypress', function() {                console.log('我按下了press');            })            //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keydown', function() {                console.log('我按下了down');            })            // 4. 三个事件的执行顺序  keydown -- keypress -- keyup    </script>
```



>   **注意：**
>
>   **1.** **如果使用**addEventListener **不需要加** **on**
>
>   \2. 
>
>   onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等。
>
>   \3. 
>
>   三个事件的执行顺序是： keydown -- keypress --- keyup



##### keyCode属性

键盘事件的

```
    <script>        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值        // 1. 我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65        // 2. 我们的keypress 事件 区分字母大小写  a  97 和 A 得到的是65        document.addEventListener('keyup', function(e) {            // console.log(e);            console.log('up:' + e.keyCode);            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键            if (e.keyCode === 65) {                alert('您按下的a键');            } else {                alert('您没有按下a键')            }        })        document.addEventListener('keypress', function(e) {            // console.log(e);            console.log('press:' + e.keyCode);        })    </script>
```

>   **注意：** onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。
>
>   在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键）
>
>   Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值





#### 案例

##### 跟随鼠标天使

![image-20210318163000778](TyporaImg/image-20210318163000778.png)





```
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        img{            position: absolute;            /* width: 100px; */        }    </style></head><body>    <img src="./images/01h5.jpg" alt=""></body><script>    document.addEventListener("mousemove",function(e){        // console.log(e.pageX);        // console.log(e.pageY);        var pic = document.querySelector("img");        pic.style.top = e.pageY - 60 + "px";        pic.style.left = e.pageX - 95 + "px";    })</script></html>
```

>   有一丝



##### s键定位搜索框



```
<body>    <input type="text"></body><script>    document.addEventListener("keyup",function(e){        /* s 115 S 83    */        // console.log(e.key);        // console.log(e.keyCode);        var inp = document.querySelector("input");        if(e.keyCode == 115 || e.keyCode == 83){            //搜索框获得焦点,使用js的方法            // focus()            inp.focus();        }    })</script>
```



##### 输入框放大文字

>   我做

![image-20210318222213887](TyporaImg/image-20210318222213887.png)

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title></head><style>    form {        /* height: 80px;        background-color: #000; */        margin-top: 60px;        position: relative;    }    form .before {        content: '';        position: absolute;        /* width: 1px;        height: 1px; */        border: 10px solid transparent;        border-top-color: #f4b5b5;        /* background-color: red; */        top: -10px;        left: 26px;        display: none;    }    .bigger {        position: absolute;        width: 180px;        height: 30px;        line-height: 30px;        top: -40px;        left: 0px;        /* border: 1px solid #CCC; */        background-color: #f4b5b5;        border-radius: 5px;        display: none;    }    input {        background-color: transparent;    }</style><body>    <form action="">        <div class="before"></div>        <input class="text" type="text">        <div class="bigger"></div>    </form></body><script>    var inp = document.querySelector("input");    document.addEventListener("keyup", function (e) {        /* s 115 S 83    */        // console.log(e.key);        // console.log(e.keyCode);        if (e.keyCode == 115 || e.keyCode == 83) {            //搜索框获得焦点,使用js的方法            // focus()            inp.focus();        }    })    var form = document.querySelector("form");    /* 获取失败 null*/    var formb = document.querySelector("form::before");    inp.addEventListener("keyup", function () {        /* 获取不了伪类节点 */        // form.firstElementChild.style.display="none";        form.lastElementChild.innerText = this.value;        if (this.value == '') {            form.firstElementChild.style.display = "none";            form.lastElementChild.style.display = "none";        } else {            form.firstElementChild.style.display = "block";            form.lastElementChild.style.display = "block";        }    })</script></html>
```

>   补充

```
    /* 获取焦点 */    inp.addEventListener("focus", function () {        if (this.value == '') {            form.firstElementChild.style.display = "none";            form.lastElementChild.style.display = "none";        } else {            form.firstElementChild.style.display = "block";            form.lastElementChild.style.display = "block";        }    })    /* 失去焦点 */    inp.addEventListener("blur", function () {        form.firstElementChild.style.display = "none";        form.lastElementChild.style.display = "none";    })
```



## BOM

BOM（Browser Object Model）即**浏览器对象模型**

### 顶级对象

```
window 对象是浏览器的顶级对象，它具有双重角色。1. 它是 JS 访问浏览器窗口的一个接口。2. 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。注意：window下的一个特殊属性 window.name
```

![image-20210318225933339](TyporaImg/image-20210318225933339.png)





### window加载

```
window.onload = function(){}                    window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 					文件等), 就调用的处理函数。                    window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。					如果使用 addEventListener 则没有限制window.addEventListener("load",function(){});document.addEventListener('DOMContentLoaded',function(){})                    DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。                    Ie9以上才支持                    如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用                    户的体验，此时用 DOMContentLoaded 事件比较合适。
```



### 调整窗口大小

```
window.onresize = function(){}window.addEventListener("resize",function(){});window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。             注意：                          1. 只要窗口大小发生像素变化，就会触发这个事件。             2. 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度
```

### 定时器

#### setTimeout

```
    <script>        // 1. setTimeout         // 语法规范：  window.setTimeout(调用函数, 延时时间);        // 1. 这个window在调用的时候可以省略        // 2. 这个延时时间单位是毫秒 但是可以省略，如果省略默认的是0        // 3. 这个调用函数可以直接写函数 还可以写 函数名 还有一个写法 '函数名()'        // 4. 页面中可能有很多的定时器，我们经常给定时器加标识符 （名字)        // setTimeout(function() {        //     console.log('时间到了');        // }, 2000);        function callback() {            console.log('爆炸了');        }        var timer1 = setTimeout(callback, 3000);        var timer2 = setTimeout(callback, 5000);        // setTimeout('callback()', 3000); // 我们不提倡这个写法    </script>
```



#### clearTimeout

```
window.clearTimeout(timeoutID)		clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。		            注意：            1. window 可以省略。            2. 里面的参数就是定时器的标识符 。
```



#### **setInterval**



```
window.setInterval(回调函数, [间隔的毫秒数]);setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。                                注意：                                1. window 可以省略。                2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()' 三种形式。                3. 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。                4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。                 5. 第一次执行也是间隔毫秒数之后执行，之后每					隔毫秒数就执行一次。
```

#### clearInterval

```
停止 setInterval() 定时器            window.clearInterval(intervalID);            clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。                    注意：                    1. window 可以省略。                    2. 里面的参数就是定时器的标识符 。                                                                                    <script>        var begin = document.querySelector('.begin');        var stop = document.querySelector('.stop');        var timer = null; // 全局变量  null是一个空对象   //undefined 容易出问题        begin.addEventListener('click', function() {            timer = setInterval(function() {                console.log('ni hao ma');            }, 1000);        })        stop.addEventListener('click', function() {            clearInterval(timer);        })    </script>
```







### this指向问题

```
// 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）// 2. 方法调用中谁调用this指向谁// 3. 构造函数中this指向构造函数的实例this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象现阶段，我们先了解一下几个this指向1. 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）2. 方法调用中谁调用this指向谁3.构造函数中this指向构造函数的实例
```

### 同步异步

```
同步任务同步任务都在主线程上执行，形成一个执行栈。 异步任务JS 的异步是通过回调函数实现的。一般而言，异步任务有以下三种类型: 1、普通事件，如 click、resize 等 2、资源加载，如 load、error 等 3、定时器，包括 setInterval、setTimeout 等异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）
```

#### 执行过程

```
1. 先执行执行栈中的同步任务。 2. 异步任务（回调函数）放入任务队列中。3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
```

![image-20210319005933643](TyporaImg/image-20210319005933643.png)

![image-20210319010001365](TyporaImg/image-20210319010001365.png)









### location对象





####  **URL**

统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址。互联网上的每个文件都有

一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

URL 的一般语法格式为：

protocol://host[:port]/path/[?query]#fragment

 http://www.itcast.cn/index.html?name=andy&age=18#link

![image-20210319012143399](TyporaImg/image-20210319012143399.png)

>   `端口号`
>
>   所谓的端口，就好像是门牌号一样，[客户端](https://baike.baidu.com/item/客户端/101081)可以通过ip地址找到对应的[服务器端](https://baike.baidu.com/item/服务器端/3369401)，但是服务器端是有很多端口的，每个[应用程序](https://baike.baidu.com/item/应用程序/5985445)对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口进行区分，将每个端口进行了编号，这就是端口号

#### **location 对象的属性**

案例5s跳转

![image-20210319012217592](TyporaImg/image-20210319012217592.png)

>   href成功跳转后,原控制台信息将消失…



#### **location 对象的方法**

![image-20210319012305413](TyporaImg/image-20210319012305413.png)



```
<body>    <button>点击</button>    <script>        var btn = document.querySelector('button');        btn.addEventListener('click', function() {            // 记录浏览历史，所以可以实现后退功能            // location.assign('http://www.itcast.cn');            // 不记录浏览历史，所以不可以实现后退功能            // location.replace('http://www.itcast.cn');            location.reload(true);        })    </script></body>
```

### **navigator 对象**

```
navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。下面前端代码可以判断用户那个终端打开页面，实现跳转
```

>   script里直接写

```
if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { 		window.location.href = ""; //手机} else { 		window.location.href = ""; //电脑}
```

>    跳转后原代码失效

![image-20210319142841644](TyporaImg/image-20210319142841644.png)

###  **history 对象**

```
window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。
```

![image-20210319014055326](TyporaImg/image-20210319014055326.png)

```
history 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。
```

![image-20210319014113616](TyporaImg/image-20210319014113616.png)











### 案例

#### 自动消失广告

```
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        .ad{            width: 200px;            height: 200px;            background-color: #bfa;        }    </style>    <script>        window.addEventListener("load",function(){            var ad = document.querySelector(".ad");            setTimeout(function(){                ad.style.display = "none";            },1000);        })    </script></head><body>    <div class="ad"></div></body></html>
```

#### 倒计时

```
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        .time{            width: 300px;            height: 200px;            line-height: 200px;            background-color: #bfa;        }    </style></head><body>    <div class="time"></div></body><script>    function countDown(time) {        var nowTime = +new Date(); // 返回的是当前时间总的毫秒数        var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数        var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数         var d = parseInt(times / 60 / 60 / 24); // 天        d = d < 10 ? '0' + d : d;        var h = parseInt(times / 60 / 60 % 24); //时        h = h < 10 ? '0' + h : h;        var m = parseInt(times / 60 % 60); // 分        m = m < 10 ? '0' + m : m;        var s = parseInt(times % 60); // 当前的秒        s = s < 10 ? '0' + s : s;        return d + '天' + h + '时' + m + '分' + s + '秒';    }    var div = document.querySelector(".time");    setInterval(() => {        div.innerText = countDown("2022-1-1");            }, 100);</script></html>
```

>       setInterval(() => {
>           div.innerText = countDown("2022-1-1");
>
>       }, 100);

>   啥简写



#### 距离春节

```
<!DOCTYPE html><html lang="en"><head>	<meta charset="UTF-8">	<meta http-equiv="X-UA-Compatible" content="IE=edge">	<meta name="viewport" content="width=device-width, initial-scale=1.0">	<title>Document</title>	<style>		.out {			width: 100%;			height: 100%;			display: flex;		}		.flash-box {			display: flex;			flex-direction: column;			justify-content: center;			align-items: center;			width: 313px;			height: 455px;			margin: auto;			box-sizing: border-box;			background-color: #E83632;		}		.flash-t {			font-size: 22px;			color: #fff;		}		.flash-e {			font-size: 20px;			color: rgba(255, 255, 255, .8);		}		p {			font-size: 18px;		}		ul {			list-style: none;			display: flex;			justify-content: space-around;			padding: 0;			width: 297px;			height: 64px;		}		ul li {			width: 64px;			height: 64px;			text-align: center;			line-height: 64px;			background-color: #372D31;			color: #fff;			font-size: 20px;			text-decoration: line-through 1px solid #e83632;		}	</style></head><body>	<div class="out">		<div class="flash-box">			<div class="flash-t">京东秒杀</div>			<div class="flash-e">FLASH DEALS</div>			<p>距离春节还有</p>			<ul>				<li>01天</li>				<li>01时</li>				<li>49分</li>				<li>46秒</li>			</ul>		</div>	</div></body><script>	// return d + '天' + h + '时' + m + '分' + s + '秒';	/* 2022.2.1 */	var ul = document.querySelector("ul");	window.setInterval(function () {		var nowTime = +new Date(); // 返回的是当前时间总的毫秒数		var inputTime = +new Date("2022.2.1"); // 返回的是用户输入时间总的毫秒数		var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 		var d = parseInt(times / 60 / 60 / 24); // 天		d = d < 10 ? '0' + d : d;		var h = parseInt(times / 60 / 60 % 24); //时		h = h < 10 ? '0' + h : h;		var m = parseInt(times / 60 % 60); // 分		m = m < 10 ? '0' + m : m;		var s = parseInt(times % 60); // 当前的秒		s = s < 10 ? '0' + s : s;		ul.children[0].innerHTML = d + " 天";		ul.children[1].innerHTML = h + " 时";		ul.children[2].innerHTML = m + " 分";		ul.children[3].innerHTML = s + " 秒";	}, 1000)	// countDown("2022.2.1");</script></html>
```





#### 发送短信

```
<body>    手机号码： <input type="number"> <button>发送</button>    <script>        // 按钮点击之后，会禁用 disabled 为true         // 同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改        // 里面秒数是有变化的，因此需要用到定时器        // 定义一个变量，在定时器里面，不断递减        // 如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态        var btn = document.querySelector('button');        var time = 3; // 定义剩下的秒数        btn.addEventListener('click', function() {            btn.disabled = true;            var timer = setInterval(function() {                if (time == 0) {                    // 清除定时器和复原按钮                    clearInterval(timer);                    btn.disabled = false;                    btn.innerHTML = '发送';                } else {                    btn.innerHTML = '还剩下' + time + '秒';                    time--;                }            }, 1000);        })    </script></body>
```

>   btn.disabled = true;



#### 5秒跳转页面

```
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title></head><body>    <button>点击</button>    <div></div>    <script>        var btn = document.querySelector('button');        var div = document.querySelector('div');        btn.addEventListener('click', function() {            // console.log(location.href);            location.href = 'http://www.itcast.cn';        })        var timer = 5;        setInterval(function() {            if (timer == 0) {                location.href = 'http://www.itcast.cn';            } else {                div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页';                timer--;            }        }, 1000);    </script></body></html>
```

#### red欢迎您

![image-20210319013118771](TyporaImg/image-20210319013118771.png)

## PC网页特效

### **offset**

```
offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 获得元素距离带有定位父元素的位置 获得元素自身的大小（宽度高度）  注意： 返回的数值都不带单位
```

![image-20210319184820604](TyporaImg/image-20210319184820604.png)

>   注意:
>
>   这些系列自己带单位





### offset / style区别



```
offset             可以得到任意样式表中样式值             offset系列获得数值没有单位             offsetWidth 包含padding+border+width             offsetWidth 等属性是只读属性，只能获取不能赋值  				所以，我们想要获取元素大小位置，用offset更合适style            只能得行内样式表样式值            style.width 获得的是带有单位的字符串            style.width 获得不包含padding和border 的值            style.width 是可读写属性，可以获取也可以赋值             				所以，我们想要给元素更改值，则需要用style改变
```



| offset                                         | style                                         |
| ---------------------------------------------- | --------------------------------------------- |
| offset 可以得到任意样式表中的样式值            | style 只能得到行内样式表中的样式值            |
| offset 系列获得的数值是没有单位的              | style.width 获得的是带有单位的字符串          |
| offsetWidth 包含padding+border+width           | style.width 获得不包含padding和border 的值    |
| offsetWidth 等属性是只读属性，只能获取不能赋值 | style.width 是可读写属性，可以获取也可以赋值  |
| 所以，我们想要获取元素大小位置，用offset更合适 | 所以，我们想要给元素更改值，则需要用style改变 |

![image-20210320190454129](TyporaImg/image-20210320190454129.png)







### client

![image-20210320191708354](TyporaImg/image-20210320191708354.png)

![image-20210320191722012](TyporaImg/image-20210320191722012.png) 	



### 立即执行函数

```
立即执行函数 (function() {})() 或者 (function(){}())主要作用： 创建一个独立的作用域。 避免了命名冲突问题
```

```
    <script>        // 1.立即执行函数: 不需要调用，立马能够自己执行的函数        function fn() {            console.log(1);        }        fn();        // 2. 写法 也可以传递参数进来        // 1.(function() {})()    或者  2. (function(){}());        (function(a, b) {            console.log(a + b);            var num = 10;        })(1, 2); // 第二个小括号可以看做是调用函数        (function sum(a, b) {            console.log(a + b);            var num = 10; // 局部变量        }(2, 3));        // 3. 立即执行函数最大的作用就是 独立创建了一个作用域, 里面所有的变量都是局部变量 不会有命名冲突的情况    </script>
```



### **scroll**

scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。

![image-20210321125607424](TyporaImg/image-20210321125607424.png)

![image-20210321125622915](TyporaImg/image-20210321125622915.png)





```js
返回顶部滚动窗口至文档中的特定位置。window.scroll(x, y) 注意，里面的x和y 								不跟单位，直接写数字
```



### onscroll / pageYOffset

```
页面被卷去的头部如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。4. 注意页面滚动的距离通过 window.pageXOffset 获得
```



### 三大系列总结

![image-20210321141739138](TyporaImg/image-20210321141739138.png)

```
他们主要用法：1. offset系列 经常用于获得元素位置 offsetLeft offsetTop2. client 经常用于获取元素大小 clientWidth clientHeight3. scroll 经常用于获取滚动距离 scrollTop scrollLeft 4. 注意页面滚动的距离通过 window.pageXOffset 获得
```



### mouseenter / mouseover

```
 当鼠标移动到元素上时就会触发 mouseenter 事件 类似 mouseover，它们两者之间的差别是 mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter 只会经过自身盒子触发 之所以这样，就是因为mouseenter不会冒泡 跟mouseenter搭配 鼠标离开 mouseleave 同样不会冒泡
```



### 动画基本原理

```
4.1 动画实现原理核心原理：通过定时器 setInterval() 不断移动盒子位置。实现步骤：1. 获得盒子当前位置2. 让盒子在当前位置加上1个移动距离3. 利用定时器不断重复这个操作4. 加一个结束定时器的条件5. 注意此元素需要添加定位，才能使用element.style.left
```



### 动画函数封装

```
动画函数简单封装注意函数需要传递2个参数，动画对象和移动到的距离
```



### 不同动画指定不同定时器

```
如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。
```

>   核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。

```css
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        div {            position: absolute;            left: 0;            width: 100px;            height: 100px;            background-color: pink;        }                span {            position: absolute;            left: 0;            top: 200px;            display: block;            width: 150px;            height: 150px;            background-color: purple;        }    </style></head><body>    <button>点击夏雨荷才走</button>    <div></div>    <span>夏雨荷</span>    <script>        // var obj = {};        // obj.name = 'andy';        // 简单动画函数封装obj目标对象 target 目标位置        // 给不同的元素指定了不同的定时器        function animate(obj, target) {            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器            // 解决方案就是 让我们元素只有一个定时器执行            // 先清除以前的定时器，只保留当前的一个定时器执行            clearInterval(obj.timer);            obj.timer = setInterval(function() {                if (obj.offsetLeft >= target) {                    // 停止动画 本质是停止定时器                    clearInterval(obj.timer);                }                obj.style.left = obj.offsetLeft + 1 + 'px';            }, 30);        }        var div = document.querySelector('div');        var span = document.querySelector('span');        var btn = document.querySelector('button');        // 调用函数        animate(div, 300);        btn.addEventListener('click', function() {            animate(span, 200);        })    </script></body></html>
```

>   自己写的

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        .a{            position: absolute;            top: 0;            left: 0;            width: 200px;            height: 200px;            margin-top: 50px;            background-color: #bfa;            /* overflow: hidden; */        }    </style></head><body>    <div class="a"></div>    <button class="b">button</button></body><script>    function animate(obj , target){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //目标600 , 结果522.78px , 结果差这么多 ??            //原因:            //当还有最后一段距离时 , step/10 ≈ 0 ,此时定时器没有清除            //解决:            //向上取整            step = Math.ceil((target - obj.offsetLeft)/100);            obj.style.left = obj.offsetLeft + step + "px";//步骤 'x'            console.log("定时器没有清除")            if(obj.offsetLeft>=target){                clearInterval(obj.timer);                //避免到点后再点按钮执行步骤 'x'                obj.style.left = target + "px";            }        }, 1);    }    var btn = document.querySelector(".b");    btn.addEventListener("click",function(){        animate(a , 600);    })    var a = document.querySelector(".a");    var obj = {}    obj.name = 1;    obj.name = 2;</script></html>
```



### 缓动动画原理

```
缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来思路：1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。2. 核心算法： (目标值 - 现在的位置 ) / 10 做为每次移动的距离 步长3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器 4. 注意步长值需要取整
```

```css
    <script>        // 缓动动画函数封装obj目标对象 target 目标位置        // 思路：        // 1. 让盒子每次移动的距离慢慢变小， 速度就会慢慢落下来。        // 2. 核心算法：(目标值 - 现在的位置) / 10 做为每次移动的距离 步长        // 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器        function animate(obj, target) {            // 先清除以前的定时器，只保留当前的一个定时器执行            clearInterval(obj.timer);            obj.timer = setInterval(function() {                // 步长值写到定时器的里面                var step = (target - obj.offsetLeft) / 10;                if (obj.offsetLeft == target) {                    // 停止动画 本质是停止定时器                    clearInterval(obj.timer);                }                // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10                obj.style.left = obj.offsetLeft + step + 'px';            }, 15);        }        var span = document.querySelector('span');        var btn = document.querySelector('button');        btn.addEventListener('click', function() {                // 调用函数                animate(span, 500);            })            // 匀速动画 就是 盒子是当前的位置 +  固定的值 10             // 缓动动画就是  盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10）    </script>
```

>   自己:

```css
    function animate(obj , target){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //目标600 , 结果522.78px , 结果差这么多 ??            //原因:            //当还有最后一段距离时 , step/10 ≈ 0 ,此时定时器没有清除            //解决:            //向上取整            step = Math.ceil((target - obj.offsetLeft)/100);            obj.style.left = obj.offsetLeft + step + "px";//步骤 'x'            console.log("定时器没有清除")            if(obj.offsetLeft>=target){                clearInterval(obj.timer);                //避免到点后再点按钮执行步骤 'x'                obj.style.left = target + "px";            }        }, 1);    }
```



### 不同目标之间移动

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        .a{            position: absolute;            top: 0;            left: 0;            width: 200px;            height: 200px;            margin-top: 50px;            background-color: #bfa;            /* overflow: hidden; */        }    </style></head><body>    <div class="a"></div>    <button class="b800">button800</button>    <button class="b500">button500</button></body><script>    function animate(obj , target , callback){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //目标600 , 结果522.78px , 结果差这么多 ??            //原因:            //当还有最后一段距离时 , step/10 ≈ 0 ,此时定时器没有清除            //解决:            //向上取整            step = step > 0?Math.ceil((target - obj.offsetLeft)/10):Math.floor((target - obj.offsetLeft)/10);            obj.style.left = obj.offsetLeft + step + "px";//步骤 'x'            console.log("定时器没有清除")            //why 使用 ==             //  不使用 >=            //原因:            //左移导致清除定时器            if(obj.offsetLeft == target){                clearInterval(obj.timer);                //避免到点后再点按钮执行步骤 'x'                obj.style.left = target + "px";                //判断有无回调函数                if(callback){                    callback();                }            }        }, 1);    }    var b800 = document.querySelector(".b800");    var b500 = document.querySelector(".b500");    b800.addEventListener("click",function(){        animate(a , 800);    })    b500.addEventListener("click",function(){        animate(a , 500);    })    var a = document.querySelector(".a");    var obj = {}    obj.name = 1;    obj.name = 2;</script></html>
```



### 动画封装函数

```js
    function animate(obj , target , callback){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //目标600 , 结果522.78px , 结果差这么多 ??            //原因:            //当还有最后一段距离时 , step/10 ≈ 0 ,此时定时器没有清除            //解决:            //向上取整            step = (target - obj.offsetLeft)/10;            step = step > 0?Math.ceil(step):Math.floor(step);            obj.style.left = obj.offsetLeft + step + "px";//步骤 'x'            console.log("定时器没有清除")            //why 使用 ==             //  不使用 >=            //原因:            //左移导致清除定时器            if(obj.offsetLeft == target){                clearInterval(obj.timer);                //避免到点后再点按钮执行步骤 'x'                obj.style.left = target + "px";                //判断有无回调函数                if(callback){                    callback();                }            }        }, 1);    }/* 添加垂直缓慢动画 */function animate(obj , target){    clearInterval(obj.timer);    var step = 0;    //给定时器取名 , 如果不清除 , 会有很多重名定时器    obj.timer = setInterval(() => {        console.log("a")        step = (target - obj.pageYOffset)/10;        step = step > 0?Math.ceil(step):Math.floor(step);        scroll(0,step + obj.pageYOffset);        /* 因为页面滚动会影响step , 当与target相差1px时 , 算作到达 */        if(step == 1){            clearInterval(obj.timer);        }    }, 1);}
```





### 添加回调函数

```
回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。 回调函数写的位置：定时器结束的位置。
```

```css
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        .a{            position: absolute;            top: 0;            left: 0;            width: 200px;            height: 200px;            margin-top: 50px;            background-color: #bfa;            /* overflow: hidden; */        }    </style></head><body>    <div class="a"></div>    <button class="b800">button800</button>    <button class="b500">button500</button></body><script>    function animate(obj , target , callback){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //目标600 , 结果522.78px , 结果差这么多 ??            //原因:            //当还有最后一段距离时 , step/10 ≈ 0 ,此时定时器没有清除            //解决:            //向上取整            step = step > 0?Math.ceil((target - obj.offsetLeft)/10):Math.floor((target - obj.offsetLeft)/10);            obj.style.left = obj.offsetLeft + step + "px";//步骤 'x'            console.log("定时器没有清除")            //why 使用 ==             //  不使用 >=            //原因:            //左移导致清除定时器            if(obj.offsetLeft == target){                clearInterval(obj.timer);                //避免到点后再点按钮执行步骤 'x'                obj.style.left = target + "px";                //判断有无回调函数                if(callback){                    callback();                }            }        }, 1);    }    var b800 = document.querySelector(".b800");    var b500 = document.querySelector(".b500");    b800.addEventListener("click",function(){        animate(a , 800);    })    b500.addEventListener("click",function(){        animate(a , 500);    })    var a = document.querySelector(".a");    var obj = {}    obj.name = 1;    obj.name = 2;</script></html>
```

### 封装单独JS文件

```
因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。1. 单独新建一个JS文件。2. HTML文件引入 JS 文件。
```



### 案例

#### 获取盒子内鼠标坐标

```
	<style>		.out{			width: 400px;			height: 400px;			background-color: #bfa;			margin: 100px;		}	</style></head><body>	<div class="out">			</div></body><script>	var div = document.querySelector("div");	document.addEventListener("click",function(e){		var px = e.pageX;		var py = e.pageY;		var dx = div.offsetLeft;		var dy = div.offsetTop;		var x = px - dx;		var y = py - dy;		console.log(x,y);	})</script>
```



#### 拖动窗口

![image-20210319233535574](TyporaImg/image-20210319233535574.png)

    <script>    // 1. 获取元素    var login = document.querySelector('.login');    var mask = document.querySelector('.login-bg');    var link = document.querySelector('#link');    var closeBtn = document.querySelector('#closeBtn');    var title = document.querySelector('#title');    // 2. 点击弹出层这个链接 link  让mask 和login 显示出来    link.addEventListener('click', function() {            mask.style.display = 'block';            login.style.display = 'block';        })        // 3. 点击 closeBtn 就隐藏 mask 和 login     closeBtn.addEventListener('click', function() {            mask.style.display = 'none';            login.style.display = 'none';        })        // 4. 开始拖拽        // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标    title.addEventListener('mousedown', function(e) {        var x = e.pageX - login.offsetLeft;        var y = e.pageY - login.offsetTop;        // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值        document.addEventListener('mousemove', move)        function move(e) {            login.style.left = e.pageX - x + 'px';            login.style.top = e.pageY - y + 'px';        }        // (3) 鼠标弹起，就让鼠标移动事件移除        document.addEventListener('mouseup', function() {            document.removeEventListener('mousemove', move);        })    })</script>

>   让窗口左上角跟随鼠标,再调整位置



#### 购物放大图片

##### 问题:

###### 1 开启检查才显示黄色透明框

![image-20210319222237175](TyporaImg/image-20210319222237175.png)



###### 2 鼠标移出preview-img区域还显示

解决:应该涉及什么底层原理 , 暂时不知道(猜测是设置display:block又开启定位,产生某种冲突)

..可给父元素设overflow:hidden 或 计算限制黄色区域……

![image-20210319222334572](TyporaImg/image-20210319222334572.png)

![image-20210320131625175](TyporaImg/image-20210320131625175.png)



###### 3 调试模式下js才正常执行





4 ![image-20210320002228497](TyporaImg/image-20210320002228497.png)



**问题出现原因:**

![image-20210320122418637](TyporaImg/image-20210320122418637.png)



###### 4 overflow:auto出现情形

![image-20210320130119754](TyporaImg/image-20210320130119754.png)



###### **全代码**

```css
window.addEventListener("load", function () {    var previewImg = document.querySelector(".preview_img");    var mask = document.querySelector('.mask');    var bigbox = document.querySelector('.big');    var bigImg = bigbox.children[0];    console.log(previewImg, mask, bigbox, bigImg,"*********")    previewImg.addEventListener('mouseover',function(){        console.log("over")        mask.style.display = "block";        // bigbox.style.display = "block";    })    previewImg.addEventListener('mouseout', function () {        console.log("out")        mask.style.display = "none";        bigbox.style.display = "none";        // console.log("为啥不消失")    })    previewImg.addEventListener("mousemove", function (e) {        console.log("move")        /* 鼠标页面坐标 */        var mx = e.pageX;        var my = e.pageY;        /* previewImg坐标 */        var px = previewImg.offsetLeft;        var py = previewImg.offsetTop;        /* 鼠标previewImg内坐标 */        var x =mx - px;        var y =my - py;        /* 闪烁问题 */        mask.style.left = x -150 + "px";        mask.style.top = y -150 +"px";                // console.log(mx,my)    })})
```





>   引入js文件需等页面加载完







#### mouseout探究

##### 1/单个盒子

测试正常

![image-20210320120103495](TyporaImg/image-20210320120103495.png)



##### 2/两个盒子

移入盒子,绝对定位盒子display:block , 出现:移入 , 移出 , 又移入 ,

![image-20210320120905843](TyporaImg/image-20210320120905843.png)

移入a1(移入a1)

移出a1(定位元素出现)

移入a1(又重新出现在a1中)

#### **淘宝 flexible.js 源码分析**

```
立即执行函数 (function() {})() 或者 (function(){}())主要作用： 创建一个独立的作用域。 避免了命名冲突问题
```

```
下面三种情况都会刷新页面都会触发 load 事件。1. a标签的超链接2. F5或者刷新按钮（强制刷新）3. 前进后退按钮但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。所以此时后退按钮不能刷新页面。此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件，注意这个事件给window添加。
```

```css
(function flexible(window, document) {    // 获取的html 的根元素    var docEl = document.documentElement        // dpr 物理像素比    var dpr = window.devicePixelRatio || 1    // adjust body font size  设置我们body 的字体大小    function setBodyFontSize() {        // 如果页面中有body 这个元素 就设置body的字体大小        if (document.body) {            document.body.style.fontSize = (12 * dpr) + 'px'        } else {            // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body            // 的字体大小            document.addEventListener('DOMContentLoaded', setBodyFontSize)        }    }    setBodyFontSize();    // set 1rem = viewWidth / 10    设置我们html 元素的文字大小    function setRemUnit() {        var rem = docEl.clientWidth / 10        docEl.style.fontSize = rem + 'px'    }    setRemUnit()    // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小    window.addEventListener('resize', setRemUnit)        // pageshow 是我们重新加载页面触发的事件    window.addEventListener('pageshow', function(e) {        // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小        if (e.persisted) {            setRemUnit()        }    })    // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法    if (dpr >= 2) {        var fakeBody = document.createElement('body')        var testElement = document.createElement('div')        testElement.style.border = '.5px solid transparent'        fakeBody.appendChild(testElement)        docEl.appendChild(fakeBody)        if (testElement.offsetHeight === 1) {            docEl.classList.add('hairlines')        }        docEl.removeChild(fakeBody)    }}(window, document))
```

##### pageShow/persisted

```
    window.addEventListener('pageshow', function(e) {        // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小        if (e.persisted) {            setRemUnit()        }    })
```



| // 个位数补 0 函数           |
| ---------------------------- |
| function addZero(n) {        |
| return n < 10 ? '0' + n : n; |

#### 淘宝固定侧边栏(卷去头部)

##### 分析

```
1. 原先侧边栏是绝对定位2. 当页面滚动到一定位置，侧边栏改为固定定位3. 页面继续滚动，会让 返回顶部显示出来案例分析① 需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是 document② 滚动到某个位置，就是判断页面被卷去的上部值。③ 页面被卷去的头部：可以通过window.pageYOffset 获得 如果是被卷去的左侧 window.pageXOffset④ 注意，元素被卷去的头部是 element.scrollTop , 如果是页面被卷去的头部 则是 window.pageYOffset⑤ 其实这个值 可以通过盒子的 offsetTop 可以得到，如果大于等于这个值，就可以让盒子固定定位了
```

##### 兼容

```
页面被卷去的头部兼容性解决方案需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：1. 声明了 DTD，使用 document.documentElement.scrollTop2. 未声明 DTD，使用 document.body.scrollTop3. 新方法 window.pageYOffset 和 window.pageXOffset，IE9 开始支持 function getScroll() { return { left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0, top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 }; } 使用的时候 getScroll().left
```

>   DTD:<!DOCTYPE html>

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        .slider-bar {            position: absolute;            left: 50%;            top: 300px;            margin-left: 600px;            width: 45px;            height: 130px;            background-color: pink;        }                .w {            width: 1200px;            margin: 10px auto;        }                .header {            height: 150px;            background-color: purple;        }                .banner {            height: 250px;            background-color: skyblue;        }                .main {            height: 1000px;            background-color: yellowgreen;        }                span {            display: none;            position: absolute;            bottom: 0;        }    </style></head><body>    <div class="slider-bar">        <span class="goBack">返回顶部</span>    </div>    <div class="header w">头部区域</div>    <div class="banner w">banner区域</div>    <div class="main w">主体部分</div>    <script>        //1. 获取元素        var sliderbar = document.querySelector('.slider-bar');        var banner = document.querySelector('.banner');        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面        var bannerTop = banner.offsetTop            // 当我们侧边栏固定定位之后应该变化的数值        var sliderbarTop = sliderbar.offsetTop - bannerTop;        // 获取main 主体元素        var main = document.querySelector('.main');        var goBack = document.querySelector('.goBack');        var mainTop = main.offsetTop;        // 2. 页面滚动事件 scroll        document.addEventListener('scroll', function() {            // console.log(11);            // window.pageYOffset 页面被卷去的头部            // console.log(window.pageYOffset);            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位            if (window.pageYOffset >= bannerTop) {                sliderbar.style.position = 'fixed';                sliderbar.style.top = sliderbarTop + 'px';            } else {                sliderbar.style.position = 'absolute';                sliderbar.style.top = '300px';            }            // 4. 当我们页面滚动到main盒子，就显示 goback模块            if (window.pageYOffset >= mainTop) {                goBack.style.display = 'block';            } else {                goBack.style.display = 'none';            }        })    </script></body></html>
```



#### 无限接近 1 

![image-20210321150952240](TyporaImg/image-20210321150952240.png)



#### 移入滑出

![image-20210321173241721](TyporaImg/image-20210321173241721.png)

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        .sliderbar {            position: fixed;            right: 0;            bottom: 100px;            width: 40px;            height: 40px;            text-align: center;            line-height: 40px;            cursor: pointer;            color: #fff;        }        .con {            position: absolute;            left: 0;            top: 0;            width: 200px;            height: 40px;            background-color: purple;            z-index: -1;        }    </style>    <script src="./js/animate.js"></script></head><body>    <div class="sliderbar">        <span>←</span>        <div class="con">问题反馈</div>    </div>    <script>        var sliderbar = document.querySelector(".sliderbar");        var con = document.querySelector(".con");        var span = document.querySelector("span");        sliderbar.addEventListener("mouseenter",function(){                        animate(con , -160 , function(){                span.innerHTML = "→";            })        })        //定位元素也在父元素内 ??        sliderbar.addEventListener("mouseleave",function(){            animate(con , 0 , function(){                span.innerHTML = "←";            })        })    </script></body></html>
```

>   //绝对定位的子元素也在父元素内 ?? 不算离开父元素
>
>   引入js文件
>
>   <script src="./js/animate.js"></script>



#### ↓↓↓↓↓常见网页特效案例↓↓↓↓↓

#### 轮播图

尚品汇作业



>   箭头函数https://www.liaoxuefeng.com/wiki/1022910821149312/1031549578462080#0 , 总是使用在匿名函数上
>
>   注意:this与普通函数区别
>
>   对象函数属性

##### 箭头函数

基本语法

```
参数 => 函数体
```

基本用法

```
var f = v => v;//等价于var f = function(a){ return a;}f(1);  //1
```

>   当箭头函数没有参数或者有多个参数，要用 **()** 括起来。
>
>   当箭头函数函数体有多行语句，用 **{}** 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 **{}** , 结果会自动返回。
>
>   当箭头函数要返回对象的时候，为了区分于代码块，要用 **()** 将对象包裹起来

区别普通函数

```
this绑定没有arguments没有new没有
```

>   箭头函数体中的 this 对象，不是自身的,因为自身不能new , 
>
>   而是外层的 , …呃呃呃

①②题

```
var func = () => {  // 箭头函数里面没有 this 对象，  // 此时的 this 是外层的 this 对象，即 Window   console.log(this)}func(55)  // Window  var func = () => {      console.log(arguments)}func(55);  // ReferenceError: arguments is not defined
```

箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象

```
function fn(){  setTimeout(()=>{    // 定义时，this 绑定的是 fn 中的 this 对象    console.log(this.a);  },0)}var a = 20;// fn 的 this 对象为 {a: 19}fn.call({a: 18});  // 18
```

ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。

```
// 回调函数var Person = {    'age': 18,    'sayHello': function () {      setTimeout(function () {        console.log(this.age);      });    }};var age = 20;Person.sayHello();  // 20 var Person1 = {    'age': 18,    'sayHello': function () {      setTimeout(()=>{        console.log(this.age);      });    }};var age = 20;Person1.sayHello();  // 18
```

不适合使用的场景

定义函数的方法，且该方法中包含 this

```
var Person = {    'age': 18,    'sayHello': ()=>{        console.log(this.age);      }};var age = 20;Person.sayHello();  // 20// 此时 this 指向的是全局对象 var Person1 = {    'age': 18,    'sayHello': function () {        console.log(this.age);    }};var age = 20;Person1.sayHello();   // 18// 此时的 this 指向 Person1 对象
```

需要动态 this 的时候

```
var button = document.getElementById('userClick'); button.addEventListener('click', () => {     this.classList.toggle('on'); });
```

button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。

#### 返回顶部

```
返回顶部滚动窗口至文档中的特定位置。window.scroll(x, y) 注意，里面的x和y 								不跟单位，直接写数字案例分析① 带有动画的返回顶部② 此时可以继续使用我们封装的动画函数③ 只需要把所有的left 相关的值 改为 跟 页面垂直滚动距离相关就可以了④ 页面滚动了多少，可以通过 window.pageYOffset 得到⑤ 最后是页面滚动，使用 window.scroll(x,y)
```

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        .slider-bar {            position: absolute;            left: 50%;            top: 300px;            margin-left: 600px;            width: 45px;            height: 130px;            background-color: pink;        }        .w {            width: 1200px;            margin: 10px auto;        }        .header {            height: 150px;            background-color: purple;        }        .banner {            height: 250px;            background-color: skyblue;        }        .main {            height: 1000px;            background-color: yellowgreen;        }        span {            display: none;            position: absolute;            bottom: 0;        }    </style></head><body>    <div class="slider-bar">        <span class="goBack">返回顶部</span>    </div>    <div class="header w">头部区域</div>    <div class="banner w">banner区域</div>    <div class="main w">主体部分</div>    <script>        //1. 获取元素        var sliderbar = document.querySelector('.slider-bar');        var banner = document.querySelector('.banner');        // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面        var bannerTop = banner.offsetTop        // 当我们侧边栏固定定位之后应该变化的数值        var sliderbarTop = sliderbar.offsetTop - bannerTop;        // 获取main 主体元素        var main = document.querySelector('.main');        var goBack = document.querySelector('.goBack');        var mainTop = main.offsetTop;        // 2. 页面滚动事件 scroll        document.addEventListener('scroll', function () {            // console.log(11);            // window.pageYOffset 页面被卷去的头部            // console.log(window.pageYOffset);            // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位            if (window.pageYOffset >= bannerTop) {                sliderbar.style.position = 'fixed';                sliderbar.style.top = sliderbarTop + 'px';            } else {                sliderbar.style.position = 'absolute';                sliderbar.style.top = '300px';            }            // 4. 当我们页面滚动到main盒子，就显示 goback模块            if (window.pageYOffset >= mainTop) {                goBack.style.display = 'block';            } else {                goBack.style.display = 'none';            }            // 5. goBack 添加点击事件            goBack.addEventListener("click", function () {                // scroll(0, 0);                // alert("11")                animate(window , 0);            })        })        //动画函数    function animate(obj , target , callback){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //目标600 , 结果522.78px , 结果差这么多 ??            //原因:            //当还有最后一段距离时 , step/10 ≈ 0 ,此时定时器没有清除            //解决:            //向上取整            step = (target - obj.offsetLeft)/10;            step = step > 0?Math.ceil(step):Math.floor(step);            obj.style.left = obj.offsetLeft + step + "px";//步骤 'x'            console.log("定时器没有清除")            //why 使用 ==             //  不使用 >=            //原因:            //左移导致清除定时器            if(obj.offsetLeft == target){                clearInterval(obj.timer);                //避免到点后再点按钮执行步骤 'x'                obj.style.left = target + "px";                //判断有无回调函数                if(callback){                    callback();                }            }        }, 1);    }    </script></body></html>
```



>               goBack.addEventListener("click", function () {
>                   // scroll(0, 0);
>                   // alert("11")
>                   animate(window , 0);
>               })
>               打开alert , 会一直循环 alert
>
>               **scroll(0 , step + pageYOffset);   每次加一点**





#### 筋斗云

![image-20210322192650385](TyporaImg/image-20210322192650385.png)



>   D:\A_YuHaiWei\A_Html_5\基础资料(B站）\A_javascript\java-script\JavaScript APIs 素材\jsapis_material\第五天\07-筋斗云导航栏

```html
<!DOCTYPE html><html><head lang="en">    <meta charset="UTF-8">    <title></title>    <style>        * {            margin: 0;            padding: 0        }                ul {            list-style: none;        }                body {            background-color: black;        }                .c-nav {            width: 900px;            height: 42px;            background: #fff url(images/rss.png) no-repeat right center;            margin: 100px auto;            border-radius: 5px;            position: relative;        }                .c-nav ul {            position: absolute;        }                .c-nav li {            float: left;            width: 83px;            text-align: center;            line-height: 42px;        }                .c-nav li a {            color: #333;            text-decoration: none;            display: inline-block;            height: 42px;        }                .c-nav li a:hover {            color: white;        }                .cloud {            position: absolute;            left: 0;            top: 0;            width: 83px;            height: 42px;            background: url(images/cloud.gif) no-repeat;        }    </style></head><body>    <div id="c_nav" class="c-nav">        <span class="cloud"></span>        <ul>            <li><a href="#">首页新闻</a></li>            <li><a href="#">师资力量</a></li>            <li><a href="#">活动策划</a></li>            <li><a href="#">企业文化</a></li>            <li><a href="#">招聘信息</a></li>            <li><a href="#">公司简介</a></li>            <li><a href="#">我是佩奇</a></li>            <li><a href="#">啥是佩奇</a></li>        </ul>    </div>    <script src="./animate.js"></script>    <script>        var cloud = document.querySelector(".cloud");        var c_nav = document.querySelector(".c-nav");        var lis = c_nav.querySelectorAll("li");        /* 好像这一个功能就可以了 , 哈哈哈 */        //  划到哪个元素就停在上面        var loc = 0;        for(var i = 0;i < lis.length;i ++){            lis[i].addEventListener("mouseenter",function(){                animate(cloud , this.offsetLeft);                // alert("aa")            })            lis[i].setAttribute("index",i);            //点击停在那个位置            lis[i].addEventListener("click",function(){                loc = this.offsetLeft;                // animate(cloud ,)            })                        //离开回到点击位置            lis[i].addEventListener("mouseleave",function(){                animate(cloud , loc)            })                                        }    </script></body></html>
```

>               //点击停在那个位置
>               lis[i].addEventListener("click",function(){
>                   loc = this.offsetLeft;
>                   // animate(cloud ,)
>               })
>               注意:
>
>               不能用 i 来记录loc 的值 ,因为循环添加完后 i 的值为length , 再次点击赋的是length





## 移动端网页特效



```
 触屏事件概述移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。常见的触屏事件如下：
```

![image-20210322201906793](TyporaImg/image-20210322201906793.png)

| 触屏touch事件 | 说明                                    |
| ------------- | --------------------------------------- |
| touchstart    | 鼠标点一下                              |
| touchmove     | 鼠标点之后按住不放并滑动 , 直到松开鼠标 |
| touchend      | 松开鼠标                                |



### touch触摸事件举例

```
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        div {            width: 100px;            height: 100px;            background-color: pink;        }    </style></head><body>    <div></div>    <script>        // 1. 获取元素        // 2. 手指触摸DOM元素事件        var div = document.querySelector('div');        div.addEventListener('touchstart', function() {            console.log('我摸了你');        });        // 3. 手指在DOM元素身上移动事件        div.addEventListener('touchmove', function() {            console.log('我继续摸');        });        // 4. 手指离开DOM元素事件        div.addEventListener('touchend', function() {            console.log('轻轻的我走了');        });    </script></body></html>
```



### 触摸事件对象

```
触摸事件对象（TouchEvent）TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等touchstart、touchmove、touchend 三个事件都会各自有事件对象。触摸事件对象重点我们看三个常见对象列表：
```

![image-20210322204216679](TyporaImg/image-20210322204216679.png)

```
    <script>        // 触摸事件对象        // 1. 获取元素        // 2. 手指触摸DOM元素事件        var div = document.querySelector('div');        div.addEventListener('touchstart', function(e) {            // console.log(e);            // touches 正在触摸屏幕的所有手指的列表             // targetTouches 正在触摸当前DOM元素的手指列表            // 如果侦听的是一个DOM元素，他们两个是一样的            // changedTouches 手指状态发生了改变的列表 从无到有 或者 从有到无            // 因为我们一般都是触摸元素 所以最经常使用的是 targetTouches            console.log(e.targetTouches[0]);            // targetTouches[0] 就可以得到正在触摸dom元素的第一个手指的相关信息比如 手指的坐标等等        });        // 3. 手指在DOM元素身上移动事件        div.addEventListener('touchmove', function() {        });        // 4. 手指离开DOM元素事件        div.addEventListener('touchend', function(e) {            // console.log(e);            // 当我们手指离开屏幕的时候，就没有了 touches 和 targetTouches 列表            // 但是会有 changedTouches        });    </script>
```



### 拖动元素

![image-20210322204234223](TyporaImg/image-20210322204234223.png)

```
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        div {            position: absolute;            left: 0;            width: 100px;            height: 100px;            background-color: pink;        }    </style></head><body>    <div></div>    <script>        // （1） 触摸元素 touchstart：  获取手指初始坐标，同时获得盒子原来的位置        // （2） 移动手指 touchmove：  计算手指的滑动距离，并且移动盒子        // （3） 离开手指 touchend:        var div = document.querySelector('div');        var startX = 0; //获取手指初始坐标        var startY = 0;        var x = 0; //获得盒子原来的位置        var y = 0;        div.addEventListener('touchstart', function(e) {            //  获取手指初始坐标            startX = e.targetTouches[0].pageX;            startY = e.targetTouches[0].pageY;            x = this.offsetLeft;            y = this.offsetTop;        });        div.addEventListener('touchmove', function(e) {            //  计算手指的移动距离： 手指移动之后的坐标减去手指初始的坐标            var moveX = e.targetTouches[0].pageX - startX;            var moveY = e.targetTouches[0].pageY - startY;            // 移动我们的盒子 盒子原来的位置 + 手指移动的距离            this.style.left = x + moveX + 'px';            this.style.top = y + moveY + 'px';            e.preventDefault(); // 阻止屏幕滚动的默认行为        });    </script></body></html>
```

```html
<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta http-equiv="X-UA-Compatible" content="IE=edge">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Document</title>  <style>    div {      position: absolute;      left: 0;      top: 0;      width: 150px;      height: 150px;      background-color: #bfa;    }  </style></head><body>  <div></div>  <script>    var div = document.querySelector("div");    var pageX = 0;    var pageY = 0;    var x = 0;    var y = 0;    var moveX = 0    var moveY = 0    div.addEventListener("touchstart", function (e) {      pageX = e.targetTouches[0].pageX;      pageY = e.targetTouches[0].pageY;      //元素属性      x = this.offsetLeft;      y = this.offsetTop;      // console.log(e.touches)      // console.log(e.targetTouches)      // console.log(e.changedTouches)      console.log("我摸了你");    })    div.addEventListener("touchmove", function (e) {      e.preventDefault(); //  dom 标准写法      moveX = e.targetTouches[0].pageX - pageX;      moveY = e.targetTouches[0].pageY - pageY;      div.style.left = x + moveX + "px"      div.style.top = y + moveY + "px"      console.log("我继续摸");    })    div.addEventListener("touchend", function (e) {      // console.log("我走了");    })  </script></body></html>
```

>   ```js
>    //元素属性 x = this.offsetLeft; y = this.offsetTop;
>   ```

### classList

```
classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。该属性用于在元素中添加，移除及切换 CSS 类。有以下方法添加类：element.classList.add（’类名’）；focus.classList.add(‘current’);移除类：element.classList.remove（’类名’）;focus.classList.remove(‘current’);切换类：element.classList.toggle（’类名’）；focus.classList.toggle(‘current’);注意以上方法里面，所有类名都不带点
```

### click延时解决

```
移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。解决方案：
```

```
1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。 <meta name="viewport" content="user-scalable=no">
```

```
2. 利用touch事件自己封装这个事件解决 300ms 延迟。原理就是：1. 当我们手指触摸屏幕，记录当前触摸时间2. 当我们手指离开屏幕， 用离开的时间减去触摸的时间3. 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击//封装tap，解决click 300ms 延时function tap (obj, callback) { var isMove = false; var startTime = 0; // 记录触摸时候的时间变量 obj.addEventListener('touchstart', function (e) { startTime = Date.now(); // 记录触摸时间 }); obj.addEventListener('touchmove', function (e) { isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击 }); obj.addEventListener('touchend', function (e) { if (!isMove && (Date.now() - startTime) < 150) { // 如果手指触摸和离开时间小于150ms 算点击 callback && callback(); // 执行回调函数 } isMove = false; // 取反 重置 startTime = 0; });}//调用  tap(div, function(){ // 执行代码 });
```

```
3. 使用插件。 fastclick 插件解决 300ms 延迟。fastclick 插件解决 300ms 延迟。 使用延时GitHub官网地址： https://github.com/ftlabs/fastclick使用:1/引入fastclick.js(地址:D:\A_YuHaiWei\A_Html_5\基础资料(B站）\A_javascript\java-script\JavaScript APIs 素材\jsapis_material\第七天)2/script里面写下面这段代码if ('addEventListener' in document) {    document.addEventListener('DOMContentLoaded', 		  function() {    FastClick.attach(document.body);    }, false);}
```

>   立即执行函数前加; 
>
>   目的隔开其他立即执行函数





### 插件

#### Swiper 插件

中文官网地址： https://www.swiper.com.cn/ 

**使用:**

```
在线演示:	各种示例	获取swiper,下载swiper压缩包,找到看上眼的demos页面,查看源代码引入css,js文件(dist(分布)里面)1. 复制html结构代码2. 复制css样式3. 复制js到我们的js里面4. api查看js使用5. css修改找到并覆盖
```

![image-20210325144247168](TyporaImg/image-20210325144247168.png)

>   我们的js文件依赖swiper.js,所以放在后面



#### superslide 插件

http://www.superslide2.com/

```
1. 确认插件实现的功能2. 去官网查看使用说明3. 下载插件4. 打开demo实例文件，查看需要引入的相关文件，并且引入5. 复制demo实例文件中的结构html，样式css以及js代码
```



#### iscroll 插件

https://github.com/cubiq/iscroll

```
1. 确认插件实现的功能2. 去官网查看使用说明3. 下载插件4. 打开demo实例文件，查看需要引入的相关文件，并且引入5. 复制demo实例文件中的结构html，样式css以及js代码
```

### 框架

```
框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端前端常用的移动端插件有 swiper、superslide、iscroll等。框架： 大而全，一整套解决方案插件： 小而专一，某个功能的解决方案
```

#### **Bootstrap**

```
Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。它能开发PC端，也能开发移动端Bootstrap JS插件使用步骤：1. 引入相关js 文件2. 复制HTML 结构3. 修改对应样式4. 修改相应JS 参数
```

```
Carousel  旋转木马(轮播图)
```

```
使用:	
```

![image-20210325161306014](TyporaImg/image-20210325161306014.png)



### 案例

#### 移动轮播图

>   D:\A_YuHaiWei\A_Html_5\基础资料(B站）\A_javascript\java-script\JavaScript APIs 素材\jsapis_material\第七天\01-移动端轮播图



##### 自动播放及无缝滚动

![image-20210323142748578](TyporaImg/image-20210323142748578.png)



>   总结:translate 从 100 到 200 也会过渡
>
>   父元素div宽 , 子元素500%宽
>
>   setInterval函数第一次执行是直接开始执行 , 还是等间隔后执行(间隔后)

bug**解决:**

```js
window.addEventListener("load", function () {    var focus = document.querySelector(".focus");    var ul = focus.children[0];    var focusW = focus.offsetWidth;    var index = 0;    setInterval(() => {        ul.style.transition = "all .5s";        ul.style.transform = 'translateX(' + -(index) * focusW + 'px)'        index++;        //到最后一张图片后直接切换至第一张 , 然后等500ms切换到第二张 , 这里为什么要大于等于 , 先放一放(没讲)        if (index >= 4) {            ul.style.transition = "none";            ul.style.transform = 'translateX(' + 0 + 'px)'            index = 1;        }    }, 500);    //错误写法:    //到了最后一张图片后 , 等500ms , 执行index == 4 ,切换到第一张图片 ,然后又等500ms ,多等500ms原因    //     if(index == 4){    //         ul.style.transition = "none";    //         ul.style.transform = 'translateX(' + 0 + 'px)'    //         index = 0;    //     }else{    //         ul.style.transition = "all .5s";    //         ul.style.transform = 'translateX(' + -(index + 1)*focusW + 'px)'    //         index++;    //     }    // }, 500);})
```

>   还是不对 , 这B绝有问题

>   老子不做了 , 他爹的 , 全是bug
>
>   经验:索引 是索引 , 第几 是第几 ;索引在 变化;注意改变之前 , 改变之后
>
>   从0开始计数 , 掌握规律

##### 小圆点跟随变化

```
① 小圆点跟随变化效果② 把ol里面li带有current类名的选出来去掉类名 remove③ 让当前索引号 的小li 加上 current add④ 但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面1 当前索引的小圆点添加类current2 过渡之后去除所有小圆点类(解决回到索引0去除最后索引的类)(可以不用循环)
```

![image-20210324232043549](TyporaImg/image-20210324232043549.png)

##### 手指动轮播图

```
案例分析① 手指滑动轮播图② 本质就是ul跟随手指移动，简单说就是移动端拖动元素③ 触摸元素 touchstart： 获取手指初始坐标④ 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子⑤ 离开手指 touchend: 根据滑动的距离分不同的情况⑥ 如果移动距离小于 某个像素 就回弹原来位置⑦ 如果移动距离大于某个像素就上一张下一张滑动。⑧ 滑动也分为左滑动和右滑动 判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑⑨ 如果是左滑 就播放下一张 （index++） ⑩ 如果是右滑 就播放上一张 (index--)
```

##### 轮播图全代码

```js
window.addEventListener("load", function () {    //获取元素    //轮播图展示框    var focus = document.querySelector(".focus");    //轮播图盒子    var ul = focus.children[0];    //小圆点    var ol = focus.children[1];    //展示框宽    var focusW = focus.offsetWidth;    //记录轮播图片索引(从零计数,重要)    var index = 0;    //开启定时器    //实现轮播图自动滚动    var timer = setInterval(function () {        // 0 1 2 3         // ol.children[index].classList.toggle("current");        index++;        ul.style.transition = "all .3s";        //平移距离        var translateX = - index * focusW;        //进行过渡平移        ul.style.transform = 'translateX(' + translateX + 'px)';        //到最后一张图片后直接切换至第一张 , 然后等500ms切换到第二张        //ul过渡结束监听事件 加油!    }, 500);    //过渡成功后检测第一张,最后一张图片,瞬间跳转    ul.addEventListener("transitionend", function () {        // for (var i = 0; i < ol.children.length; i++) {        //     ol.children[i].classList.remove("current");        // }        // ul.style.transition = "all .3s";        //>=3这么写原因不清楚        if (index >= 3) {            //取消过渡,瞬间跳转            ul.style.transition = "none";            ul.style.transform = 'translateX(' + 0 + 'px)';            //跳转到第0张            index = 0;        } else if (index < 0) {            //跳转到第2张,            index = 2;            var translateX = - index * focusW;            ul.style.transition = "none";            ul.style.transform = 'translateX(' + translateX + 'px)';        }        //去除带current类元素        ol.querySelector(".current").classList.remove("current");        //添加当前小圆点current类        ol.children[index].classList.add("current");    })    //错误写法:    //到了最后一张图片后 , 等500ms , 执行index == 4 ,切换到第一张图片 ,然后又等500ms ,多等500ms原因    //     if(index == 4){    //         ul.style.transition = "none";    //         ul.style.transform = 'translateX(' + 0 + 'px)'    //         index = 0;    //     }else{    //         ul.style.transition = "all .5s";    //         ul.style.transform = 'translateX(' + -(index + 1)*focusW + 'px)'    //         index++;    //     }    // }, 500);    //手指滑动轮播图(只能平移!)    //手指初始位置    var staX = 0;    //手指滑动距离    var moveX = 0;    //判断是否移动    var flag = false;    //开始触屏    ul.addEventListener("touchstart", function (e) {        //清楚定时器        clearInterval(timer);        //初始水平距离        staX = e.targetTouches[0].pageX;    })    ul.addEventListener("touchmove", function (e) {        //移动了        flag = true;        //移动距离        moveX = e.targetTouches[0].pageX - staX;        //ul轮播图跟随手指移动距离(当前平移距离加手指移动距离)        var translateX = moveX - index * focusW;        //移动        ul.style.transform = 'translateX(' + translateX + 'px)';    })    ul.addEventListener("touchend", function (e) {        //移动才计算是否滚动图片        if (flag) {            //滑动大于50,滑动图片            if (Math.abs(moveX) > 50) {                //右滑moveX > 0 , index--,上一张图片索引,还没划过去                if (moveX > 0) {                    index--;                    //左滑moveX < 0 , index++                } else {                    index++;                }                //过渡效果                ul.style.transition = "all .5s";                //平移距离                var translateX = - index * focusW;                //滑到正确索引图片处                ul.style.transform = 'translateX(' + translateX + 'px)';                //滑动小于50,不滑动图片            } else {                ul.style.transition = "all .3s";                var translateX = -index * focusW;                ul.style.transform = 'translateX(' + translateX + 'px)';            }        }        //重新开启定时器        //根据经验先清除定时器        clearInterval(timer);        timer = setInterval(function () {            index++;            ul.style.transition = "all .3s";            var translateX = - index * focusW;            ul.style.transform = 'translateX(' + translateX + 'px)';        }, 500);    })})
```







##### 返回顶部模块制作

```js
    // 返回顶部模块制作    var goBack = document.querySelector('.goBack');    var nav = document.querySelector('nav');    window.addEventListener('scroll', function() {        if (window.pageYOffset >= nav.offsetTop) {            goBack.style.display = 'block';        } else {            goBack.style.display = 'none';        }    });        goBack.addEventListener("click",function(){        console.log("aa")        //缓回        animate(window, 0);        //瞬移        // window.scroll(0, 0);    })    //动画封装函数    function animate(obj , target){        clearInterval(obj.timer);        var step = 0;        //给定时器取名 , 如果不清除 , 会有很多重名定时器        obj.timer = setInterval(() => {            //向上取整            step = (target - window.pageYOffset)/10;            step = step > 0?Math.ceil(step):Math.floor(step);            //考虑简单情况,从左往右,step=多少,step只是 要移动 的距离            //还得加上原先距离            //step + obj.pageYOffset            window.scroll(0 , step + obj.pageYOffset);            if(obj.pageYOffset == target){                // 不加this返回后滑动不了底部,因为去清除函数外面的timer了                clearInterval(this.timer);            }            console.log("dd")        }, 10);    }
```



#### zy.media.js移动端视频插件

```
H5 给我们提供了 video 标签，但是浏览器的支持情况不同。不同的视频格式文件，我们可以通过source 解决。但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。这个时候我们可以使用插件方式来制作。
```

## 本地存储

```
随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。本地存储特性1、数据存储在用户浏览器中2、设置、读取方便、甚至页面刷新不丢失数据3、容量较大，sessionStorage约5M、localStorage约20M4、只能存储字符串，可以将对象JSON.stringify() 编码后存储
```



### 浏览器查看

![image-20210325162425049](TyporaImg/image-20210325162425049.png)

### window.sessionStorage

```
1、生命周期为关闭浏览器窗口2、在同一个窗口(页面)下数据可以共享3. 以键值对的形式存储使用存储数据：sessionStorage.setItem(key, value)获取数据：sessionStorage.getItem(key)删除数据：sessionStorage.removeItem(key)删除所有数据：sessionStorage.clear()
```

### window.localStorage

```
1、声明周期永久生效，除非手动删除 否则关闭页面也会存在2、可以多窗口（页面）共享（同一浏览器可以共享）3. 以键值对的形式存储使用存储数据：localStorage.setItem(key, value)获取数据：localStorage.getItem(key)删除数据：localStorage.removeItem(key)删除所有数据：localStorage.clear()
```

### 记住用户名

```js
<body>    <input type="text" id="username"> <input type="checkbox" name="" id="remember"> 记住用户名    <script>        var username = document.querySelector('#username');        var remember = document.querySelector('#remember');        if (localStorage.getItem('username')) {            username.value = localStorage.getItem('username');            remember.checked = true;        }        remember.addEventListener('change', function() {            if (this.checked) {                localStorage.setItem('username', username.value)            } else {                localStorage.removeItem('username');            }        })    </script></body>
```































