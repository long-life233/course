<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./default.css">
    <script src="./three.js"></script>
    <!-- stats库，检测动画运行帧数 -->
    <!-- <script src="./stats.min.js"></script> -->

</head>

<body>
    <div id="myStats"></div>
    <script type="module">
        import { dat } from './dat.gui.js'
        import { Stats } from './Stats.js'
        // console.log(window.__THREE__); // 135
        var scene = new THREE.Scene();
        /**
         *1 我们能看到的视角
         *2 长宽比
         *3 表示距离摄像机多近的位置开始渲染
         *4 表示多远就不能渲染了
         */
        // var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        /**
         *1 渲染场景的左边界（边界越大，黑色的分割线越大）
         *2 渲染场景的右边界
         *3 渲染场景的上边界
         *4 渲染场景的下边界
         *5 近面距离，场景从距离相机这么近的点开始渲染
         *6 远面距离，场景从距离相机这么远的点停止渲染
         */
        var camera = new THREE.OrthographicCamera(window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / -16,-10,1024)

        var render = new THREE.WebGLRenderer();
        render.setSize(window.innerWidth, window.innerHeight);
        document.querySelector("body").appendChild(render.domElement);


        var planeGeometry = new THREE.PlaneGeometry(100, 100)
        var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -0.5 * Math.PI
        plane.position.set(0, -4, 0)
        scene.add(plane)

        camera.position.x = -40;
        camera.position.y = 55;
        camera.position.z = 45;
        camera.lookAt(scene.position)

        // 环境光
        var ambientLight = new THREE.AmbientLight(0xaaaaaa);
        scene.add(ambientLight)
        // 点光源
        var spotLight = new THREE.SpotLight(0xFFFFFF);
        spotLight.position.set(-60, 40, -65);
        // spotLight.castShadow = true;
        // spotLight.shadow.mapSize = new THREE.Vector2(1024,1024)
        // spotLight.shadow.camera.far = 130;
        // spotLight.shadow.camera.near = 40
        scene.add(spotLight)


        // 坐标系
        var axes = new THREE.AxesHelper(50)
        scene.add(axes)

        var stats = addStats()
        function addStats() {
            var stats = new Stats();
            stats.domElement.style.position = 'absolute'
            stats.domElement.style.left = '10px'
            stats.domElement.style.top = '10px'
            stats.setMode(1);

            document.getElementById("myStats").appendChild(stats.domElement);
            return stats
        }


        var ctrlObj = {
            showText: "透视投影相机",
            changeCamera() {
                if (camera instanceof THREE.OrthographicCamera) { // 透视
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.x = -30;
                    camera.position.y = 45;
                    camera.position.z = 35;
                    camera.lookAt(scene.position)
                    ctrlObj.showText = "景深投影相机"
                } else {
                    camera = new THREE.OrthographicCamera(window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / 16, window.innerHeight / -16)
                    camera.position.x = -30;
                    camera.position.y = 45;
                    camera.position.z = 35;
                    camera.lookAt(scene.position)
                    ctrlObj.showText = "透视投影相机"
                }
            }
        };
        var ctrl = new dat.GUI();
        ctrl.add(ctrlObj, "showText").listen() // listen方法可以监听文本变化
        ctrl.add(ctrlObj, "changeCamera")

        var geometry = new THREE.BoxGeometry(8,8,8);
        var material = new THREE.MeshLambertMaterial({color:0xbbffaa})
        var cube1 = new THREE.Mesh(geometry,material)
        cube1.position.set(0,8,0)
        scene.add(cube1)

        for (var i = 0; i < (planeGeometry.parameters.width / 5); i++) {
            for (var j = 0; j < (planeGeometry.parameters.height / 5); j++) {
                var cubeGeo = new THREE.BoxGeometry(4, 4, 4)
                var cubeMaterial = new THREE.MeshLambertMaterial();
                cubeMaterial.color = new THREE.Color(0, Math.random() * 0.5 + 0.5, 0, 0)
                var cube = new THREE.Mesh(cubeGeo, cubeMaterial);
                cube.position.x = 5 * i + 5 / 2 - (planeGeometry.parameters.width / 2)
                cube.position.y = 3
                cube.position.z = 5 * j + 5 / 2 - (planeGeometry.parameters.height / 2)

                scene.add(cube)
            }
        }

        var pos = 0;
        renderScene();
        function renderScene() {
            pos += .1
            cube1.position.x = (10*Math.sin(pos))
            camera.lookAt(cube1.position)
            stats.update()
            requestAnimationFrame(renderScene);
            render.render(scene, camera)
        }



        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix();
            render.setSize(window.innerWidth, window.innerHeight)
        }
    </script>
</body>

</html>